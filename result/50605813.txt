目录
0.引言
在进行Linux主机的系统状态安全监控的过程中，我们常常会涉及到对系统进程信息的收集、聚类、分析等技术，因此，研究Linux进程原理能帮助我们更好的明确以下几个问题
本文的技术研究会围绕这几点进行Linux操作系统进程的基本原理研究
1.Linux进程
0x1:进程的表示
进程属于操作系统的资源，因此进程相关的元数据都保存在内核态RING0中，Linux内核涉及进程和程序的所有算法都围绕task_struct数据结构建立，该结构定义在include/sched.h中，这是操作系统中主要的一个结构，task_struct包含很多成员，将进程与各个内核子系统联系起来，关于task_struct结构体的相关知识，请参阅另一篇文章
0x2:进程的产生方式
Linux下新进程是使用fork和exec系统调用产生的
除此之外，Linux还提供了clone系统调用，clone的工作原理基本上和fork相同，所区别的是
关于Linux下进程创建的相关知识，请参阅另一篇文章

0x3:命名空间
命名空间提供了虚拟化的一种轻量级形式，使得我们可以从不同的方面来查看运行系统的全局属性，本质上，命名空间建立了系统的不同视图。未使用命名空间之前的每一项全局资源都必须包装到容器数据结构中，而资源和包含资源的命名空间构成的二元组仍然是全局唯一的。

从图中可以看到：
命名空间机制是Linux的一个重要的技术，对命名空间的支持已经有很长的时间了，主要是chroot系统调用，该方法可以将进程限制到文件系统的某一部分，因此是一种简单的命名空间机制。但真正的命名空间能够控制的功能远远超过&quot;文件系统视图&quot;
RelevantLink:
2.Linux进程的相关标识
以下是Linux和进程相关的标识ID&#20540;，我们先学习它们的基本概念，在下一节我们会学习到这些ID&#20540;间的关系、以及Linux是如何保存和组织它们的
0x1:PID(ProcessID进程ID号)
Linux系统中总是会分配一个号码用于在其命名空间中唯一地标识它们，即进程ID号(PID)，用fork或者cline产生的每个进程都由内核自动地分配一个新的唯一的PID&#20540;
&#20540;得注意的是，命名空间增加了PID管理的复杂性，PID命名空间按照层次组织，在建立一个新的命名空间时
这也就是意味着在&quot;多层次命名空间&quot;的状态下，进行具有多个PID，凡是可能看到该进程的的命名空间，都会为其分配一个PID，这种特征反映在了Linux的数据结构中，即局部ID、和全局ID

0x2:TGID(ThreadGroupID线程组ID号)

处于某个线程组(在一个进程中，通过标志CLONE_THREAD来调用clone建立的该进程的不同的执行上下文)中的所有进程都有统一的线程组ID(TGID)
如果进程没有使用线程，则它的PID和TGID相同
线程组中的&quot;主线程&quot;(Linux中线程也是进程)被称作&quot;组长(groupleader)&quot;，通过clone创建的所有线程的task_struct的group_leader成员，都会指向组长的task_struct。

在Linux系统中，一个线程组中的所有线程使用和该线程组的领头线程(该组中的第一个轻量级进程)相同的PID，并被存放在tgid成员中。只有线程组的领头线程的pid成员才会被设置为与tgid相同的&#20540;。注意，getpid()系统调用
返回的是当前进程的tgid&#20540;而不是pid&#20540;。
梳理一下这段概念，我们可以这么理解
0x3:PGID(ProcessGroupID进程组ID号)

了解了进行ID、线程组(就是单线程下的进程)ID之后，我们继续学习&quot;进程组ID&quot;，可以看出，Linux就是在将做原子的因素不断组合成更大的集合。
每个进程都会属于一个进程组(processgroup)，每个进程组中可以包含多个进程。进程组会有一个进程组领导进程(processgroupleader)，领导进程的PID成为进程组的ID(processgroupID,PGID)，以识别进程组。

图中箭头表示父进程通过fork和exec机制产生子进程。ps和cat都是bash的子进程。进程组的领导进程的PID成为进程组ID。领导进程可以先终结。此时进程组依然存在，并持有相同的PGID，直到进程组中最后一个进程终结
进程组简化了向组内的所有成员发送信号的操作，进程组中的所有进程都会收到该信号，例如，用管道连接的进程包含在同一个进程组中(管道的原理就是在创建2个子进程)

或者输入pgrp也可以，pgrp和pgid是等价的

0x4:PPID(
ParentprocessID父进程ID号)
PPID是当前进程的父进程的PID

因为ps、cat都是由bash启动的，所以它们的ppid都等于bash进程的pid
0x5:SID(SessionID会话ID)
更进一步，在shell支持工作控制(jobcontrol)的前提下，多个进程组还可以构成一个会话(session)。bash(Bourne-Againshell)支持工作控制，而sh(Bourneshell)并不支持
一个命令可以通过在末尾加上&amp;方式让它在后台运行:
信号可以通过kill的方式来发送给工作组
一个工作可以通过$fg从后台工作变为前台工作:
进程组(工作)的概念较为简单易懂。而会话主要是针对一个终端建立的。当我们打开多个终端窗口时，实际上就创建了多个终端会话。每个会话都会有自己的前台工作和后台工作。这样，我们就为进程增加了管理和运行的层次

RelevantLink:
3.进程标识编程示例
了解了进程标识的基本概念之后，接下来我们通过API编程方式来直观地了解下
0x1:父子进程、组长进程和组员进程的关系

从运行结果来看，我们可以得出几个结论

0x2:进程组更改
我们继续拿fork()产生父子进程的这个codeexample作为示例，因为正常情况下，父子进程具有相同的PGID，这个代码场景能帮助我们更好地去了解PGID的相关知识

从程序的运行结果可以看出

0x3:会话IDSessionID

从程序的运行结果可以得到如下结论
下面这张图对整个PID、PGID、SID的关系做了一个梳理

RelevantLink:
4.进程标志在Linux内核中的存储和表现形式
了解了Linux中进程标识的基本概念和API编程方式后，我们接下来继续研究一下Linux在内核中是如何去存储、组织、表现这些标识的
在task_struct中，和进程标识ID相关的域有

如果显示不完整，请另存到本地看
0x1:Linux内核Hash表
要谈Linux内核中进程标识的存储和组织，我们首先要了解Linux内核的Hash表机制，在内核中，查找是必不可少的，例如
查找技术属于数据结构算法的范畴，常用的查找算法有如下几种
本文主要学习的进程标识的存储和查找就是基于计算的HASH表查找方式

0x2:Linuxpid_hash散列表

在内核中，经常需要通过进程PID来获取进程描述符，例如
kill命令:最简单的方法可以通过遍历task_struct链表并对比pid的&#20540;来获取，但这样效率太低，尤其当系统中运行很多个进程的时候
linux内核通过PIDS散列表来解决这一问题，能快速的通过进程PID获取到进程描述符
PID散列表包含4个表，因为进程描述符包含了表示不同类型PID的字段，每种类型的PID需要自己的散列表
0x3:进程标识在内核中的存储

一个PID只对应着一个进程，但是一个PGID，TGID和SID可能对应着多个进程，所以在pid结构体中，把拥有同样PID(广义的PID)的进程放进名为tasks的成员表示的数组中，当然，不同类型的ID放在相应的数组元素中。
考虑下面四个进程：
分别用task_a,task_b,task_c和task_d表示它们的task_struct，则它们之间的联系是：
内核初始化期间动态地为4个散列表分配空间，并把它们的地址存入pid_hash数组(就是struct-&gt;pids[PIDTYPE_MAX]中)
0x4:进程标识ID在内核中的表示和使用
内核用pid_hashfn宏把PID转换为表索引
kernel/pid.c
这个宏就负责把一个PID转换为一个index，我们继续跟进hash_long这个函数
\include\linux\hash.h
对这个算法的简单理解如下

现在我们已经可以通过pid_hashfn把PID转换为一个index了，接下来我们再来想一想其中的问题
需要注意的是，与A同组的进程，他们具有同样的PGID，更具上面所解释的，这些进程构成的链表是存放在A的pids[PIDTYPE_PGID].pid.tasks指向的列表中
下面的图片说明了hash和进程链表的关系，图中TGID=4351和TGID=246具有同样的hash&#20540;。(图中的字段名称比较老，但大意是一样的，只要把pid_chain看做是pid_link结构中的node，把pid_list看做是pid结构中的tasks即可)

RelevantLink:
5.后记
在Linux的进程的标识符中有很多&quot;组&quot;的概念，Linux从最原始的PID开始，进行了逐层的封装，不断嵌套成更大的组，这也意味着，Linux中的进程序列之间并不是完全独立的关系，而是包含着很多的组合关系的，我们可以充分利用Linux操作系统本身提供的特性，来对指令序列进行聚合，从而从低维的序列信息中发现更高伟的行为模式
目录
0.引言
在进行Linux主机的系统状态安全监控的过程中，我们常常会涉及到对系统进程信息的收集、聚类、分析等技术，因此，研究Linux进程原理能帮助我们更好的明确以下几个问题
本文的技术研究会围绕这几点进行Linux操作系统进程的基本原理研究
1.Linux进程
0x1:进程的表示
进程属于操作系统的资源，因此进程相关的元数据都保存在内核态RING0中，Linux内核涉及进程和程序的所有算法都围绕task_struct数据结构建立，该结构定义在include/sched.h中，这是操作系统中主要的一个结构，task_struct包含很多成员，将进程与各个内核子系统联系起来，关于task_struct结构体的相关知识，请参阅另一篇文章
0x2:进程的产生方式
Linux下新进程是使用fork和exec系统调用产生的
除此之外，Linux还提供了clone系统调用，clone的工作原理基本上和fork相同，所区别的是
关于Linux下进程创建的相关知识，请参阅另一篇文章

0x3:命名空间
命名空间提供了虚拟化的一种轻量级形式，使得我们可以从不同的方面来查看运行系统的全局属性，本质上，命名空间建立了系统的不同视图。未使用命名空间之前的每一项全局资源都必须包装到容器数据结构中，而资源和包含资源的命名空间构成的二元组仍然是全局唯一的。

从图中可以看到：
命名空间机制是Linux的一个重要的技术，对命名空间的支持已经有很长的时间了，主要是chroot系统调用，该方法可以将进程限制到文件系统的某一部分，因此是一种简单的命名空间机制。但真正的命名空间能够控制的功能远远超过&quot;文件系统视图&quot;
RelevantLink:
2.Linux进程的相关标识
以下是Linux和进程相关的标识ID&#20540;，我们先学习它们的基本概念，在下一节我们会学习到这些ID&#20540;间的关系、以及Linux是如何保存和组织它们的
0x1:PID(ProcessID进程ID号)
Linux系统中总是会分配一个号码用于在其命名空间中唯一地标识它们，即进程ID号(PID)，用fork或者cline产生的每个进程都由内核自动地分配一个新的唯一的PID&#20540;
&#20540;得注意的是，命名空间增加了PID管理的复杂性，PID命名空间按照层次组织，在建立一个新的命名空间时
这也就是意味着在&quot;多层次命名空间&quot;的状态下，进行具有多个PID，凡是可能看到该进程的的命名空间，都会为其分配一个PID，这种特征反映在了Linux的数据结构中，即局部ID、和全局ID

0x2:TGID(ThreadGroupID线程组ID号)

处于某个线程组(在一个进程中，通过标志CLONE_THREAD来调用clone建立的该进程的不同的执行上下文)中的所有进程都有统一的线程组ID(TGID)
如果进程没有使用线程，则它的PID和TGID相同
线程组中的&quot;主线程&quot;(Linux中线程也是进程)被称作&quot;组长(groupleader)&quot;，通过clone创建的所有线程的task_struct的group_leader成员，都会指向组长的task_struct。

在Linux系统中，一个线程组中的所有线程使用和该线程组的领头线程(该组中的第一个轻量级进程)相同的PID，并被存放在tgid成员中。只有线程组的领头线程的pid成员才会被设置为与tgid相同的&#20540;。注意，getpid()系统调用
返回的是当前进程的tgid&#20540;而不是pid&#20540;。
梳理一下这段概念，我们可以这么理解
0x3:PGID(ProcessGroupID进程组ID号)

了解了进行ID、线程组(就是单线程下的进程)ID之后，我们继续学习&quot;进程组ID&quot;，可以看出，Linux就是在将做原子的因素不断组合成更大的集合。
每个进程都会属于一个进程组(processgroup)，每个进程组中可以包含多个进程。进程组会有一个进程组领导进程(processgroupleader)，领导进程的PID成为进程组的ID(processgroupID,PGID)，以识别进程组。

图中箭头表示父进程通过fork和exec机制产生子进程。ps和cat都是bash的子进程。进程组的领导进程的PID成为进程组ID。领导进程可以先终结。此时进程组依然存在，并持有相同的PGID，直到进程组中最后一个进程终结
进程组简化了向组内的所有成员发送信号的操作，进程组中的所有进程都会收到该信号，例如，用管道连接的进程包含在同一个进程组中(管道的原理就是在创建2个子进程)

或者输入pgrp也可以，pgrp和pgid是等价的

0x4:PPID(
ParentprocessID父进程ID号)
PPID是当前进程的父进程的PID

因为ps、cat都是由bash启动的，所以它们的ppid都等于bash进程的pid
0x5:SID(SessionID会话ID)
更进一步，在shell支持工作控制(jobcontrol)的前提下，多个进程组还可以构成一个会话(session)。bash(Bourne-Againshell)支持工作控制，而sh(Bourneshell)并不支持
一个命令可以通过在末尾加上&amp;方式让它在后台运行:
信号可以通过kill的方式来发送给工作组
一个工作可以通过$fg从后台工作变为前台工作:
进程组(工作)的概念较为简单易懂。而会话主要是针对一个终端建立的。当我们打开多个终端窗口时，实际上就创建了多个终端会话。每个会话都会有自己的前台工作和后台工作。这样，我们就为进程增加了管理和运行的层次

RelevantLink:
3.进程标识编程示例
了解了进程标识的基本概念之后，接下来我们通过API编程方式来直观地了解下
0x1:父子进程、组长进程和组员进程的关系

从运行结果来看，我们可以得出几个结论

0x2:进程组更改
我们继续拿fork()产生父子进程的这个codeexample作为示例，因为正常情况下，父子进程具有相同的PGID，这个代码场景能帮助我们更好地去了解PGID的相关知识

从程序的运行结果可以看出

0x3:会话IDSessionID

从程序的运行结果可以得到如下结论
下面这张图对整个PID、PGID、SID的关系做了一个梳理

RelevantLink:
4.进程标志在Linux内核中的存储和表现形式
了解了Linux中进程标识的基本概念和API编程方式后，我们接下来继续研究一下Linux在内核中是如何去存储、组织、表现这些标识的
在task_struct中，和进程标识ID相关的域有

如果显示不完整，请另存到本地看
0x1:Linux内核Hash表
要谈Linux内核中进程标识的存储和组织，我们首先要了解Linux内核的Hash表机制，在内核中，查找是必不可少的，例如
查找技术属于数据结构算法的范畴，常用的查找算法有如下几种
本文主要学习的进程标识的存储和查找就是基于计算的HASH表查找方式

0x2:Linuxpid_hash散列表

在内核中，经常需要通过进程PID来获取进程描述符，例如
kill命令:最简单的方法可以通过遍历task_struct链表并对比pid的&#20540;来获取，但这样效率太低，尤其当系统中运行很多个进程的时候
linux内核通过PIDS散列表来解决这一问题，能快速的通过进程PID获取到进程描述符
PID散列表包含4个表，因为进程描述符包含了表示不同类型PID的字段，每种类型的PID需要自己的散列表
0x3:进程标识在内核中的存储

一个PID只对应着一个进程，但是一个PGID，TGID和SID可能对应着多个进程，所以在pid结构体中，把拥有同样PID(广义的PID)的进程放进名为tasks的成员表示的数组中，当然，不同类型的ID放在相应的数组元素中。
考虑下面四个进程：
分别用task_a,task_b,task_c和task_d表示它们的task_struct，则它们之间的联系是：
内核初始化期间动态地为4个散列表分配空间，并把它们的地址存入pid_hash数组(就是struct-&gt;pids[PIDTYPE_MAX]中)
0x4:进程标识ID在内核中的表示和使用
内核用pid_hashfn宏把PID转换为表索引
kernel/pid.c
这个宏就负责把一个PID转换为一个index，我们继续跟进hash_long这个函数
\include\linux\hash.h
对这个算法的简单理解如下

现在我们已经可以通过pid_hashfn把PID转换为一个index了，接下来我们再来想一想其中的问题
需要注意的是，与A同组的进程，他们具有同样的PGID，更具上面所解释的，这些进程构成的链表是存放在A的pids[PIDTYPE_PGID].pid.tasks指向的列表中
下面的图片说明了hash和进程链表的关系，图中TGID=4351和TGID=246具有同样的hash&#20540;。(图中的字段名称比较老，但大意是一样的，只要把pid_chain看做是pid_link结构中的node，把pid_list看做是pid结构中的tasks即可)

RelevantLink:
5.后记
在Linux的进程的标识符中有很多&quot;组&quot;的概念，Linux从最原始的PID开始，进行了逐层的封装，不断嵌套成更大的组，这也意味着，Linux中的进程序列之间并不是完全独立的关系，而是包含着很多的组合关系的，我们可以充分利用Linux操作系统本身提供的特性，来对指令序列进行聚合，从而从低维的序列信息中发现更高伟的行为模式
