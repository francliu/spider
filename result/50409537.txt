上一篇《C&#43;&#43;11并发指南二(std::thread详解)》中主要讲到了std::thread的一些用法，并给出了两个小例子，本文将介绍std::mutex的用法。
Mutex又称互斥量，C&#43;&#43;11中与Mutex相关的类（包括锁类型）和函数都声明在&lt;mutex&gt;头文件中，所以如果你需要使用std::mutex，就必须包含&lt;mutex&gt;头文件。
下面以std::mutex为例介绍C&#43;&#43;11中的互斥量用法。
std::mutex是C&#43;&#43;11中最基本的互斥量，std::mutex对象提供了独占所有权的特性——即不支持递归地对std::mutex对象上锁，而std::recursive_lock则可以递归地对互斥量对象上锁。
下面给出一个与std::mutex的小例子（参考）
std::recursive_mutex与std::mutex一样，也是一种可以被上锁的对象，但是和std::mutex不同的是，std::recursive_mutex允许同一个线程对互斥量多次上锁（即递归上锁），来获得对互斥量对象的多层所有权，std::recursive_mutex释放互斥量时需要调用与该锁层次深度相同次数的unlock()，可理解为lock()次数和unlock()次数相同，除此之外，std::recursive_mutex的特性和std::mutex
大致相同。
std::time_mutex比std::mutex多了两个成员函数，try_lock_for()，try_lock_until()。
try_lock_for函数接受一个时间范围，表示在这一段时间范围之内线程如果没有获得锁则被阻塞住（与std::mutex的try_lock()不同，try_lock如果被调用时没有获得锁则直接返回false），如果在此期间其他线程释放了锁，则该线程可以获得对互斥量的锁，如果超时（即在指定时间内还是没有获得锁），则返回false。
try_lock_until函数则接受一个时间点作为参数，在指定时间点未到来之前线程如果没有获得锁则被阻塞住，如果在此期间其他线程释放了锁，则该线程可以获得对互斥量的锁，如果超时（即在指定时间内还是没有获得锁），则返回false。
下面的小例子说明了std::time_mutex的用法（参考）。
和std:recursive_mutex与std::mutex的关系一样，std::recursive_timed_mutex的特性也可以从std::timed_mutex推导出来，感兴趣的同鞋可以自行查阅。;-)
与MutexRAII相关，方便线程对互斥量上锁。例子（参考）:
与MutexRAII相关，方便线程对互斥量上锁，但提供了更好的上锁和解锁控制。例子（参考）：
好了，本文暂时讲到这里，还剩下std::try_lock，std::lock，std::call_once三个函数没有讲到，留在下一篇博客中讲吧;-)
上一篇《C&#43;&#43;11并发指南二(std::thread详解)》中主要讲到了std::thread的一些用法，并给出了两个小例子，本文将介绍std::mutex的用法。
Mutex又称互斥量，C&#43;&#43;11中与Mutex相关的类（包括锁类型）和函数都声明在&lt;mutex&gt;头文件中，所以如果你需要使用std::mutex，就必须包含&lt;mutex&gt;头文件。
下面以std::mutex为例介绍C&#43;&#43;11中的互斥量用法。
std::mutex是C&#43;&#43;11中最基本的互斥量，std::mutex对象提供了独占所有权的特性——即不支持递归地对std::mutex对象上锁，而std::recursive_lock则可以递归地对互斥量对象上锁。
下面给出一个与std::mutex的小例子（参考）
std::recursive_mutex与std::mutex一样，也是一种可以被上锁的对象，但是和std::mutex不同的是，std::recursive_mutex允许同一个线程对互斥量多次上锁（即递归上锁），来获得对互斥量对象的多层所有权，std::recursive_mutex释放互斥量时需要调用与该锁层次深度相同次数的unlock()，可理解为lock()次数和unlock()次数相同，除此之外，std::recursive_mutex的特性和std::mutex
大致相同。
std::time_mutex比std::mutex多了两个成员函数，try_lock_for()，try_lock_until()。
try_lock_for函数接受一个时间范围，表示在这一段时间范围之内线程如果没有获得锁则被阻塞住（与std::mutex的try_lock()不同，try_lock如果被调用时没有获得锁则直接返回false），如果在此期间其他线程释放了锁，则该线程可以获得对互斥量的锁，如果超时（即在指定时间内还是没有获得锁），则返回false。
try_lock_until函数则接受一个时间点作为参数，在指定时间点未到来之前线程如果没有获得锁则被阻塞住，如果在此期间其他线程释放了锁，则该线程可以获得对互斥量的锁，如果超时（即在指定时间内还是没有获得锁），则返回false。
下面的小例子说明了std::time_mutex的用法（参考）。
和std:recursive_mutex与std::mutex的关系一样，std::recursive_timed_mutex的特性也可以从std::timed_mutex推导出来，感兴趣的同鞋可以自行查阅。;-)
与MutexRAII相关，方便线程对互斥量上锁。例子（参考）:
与MutexRAII相关，方便线程对互斥量上锁，但提供了更好的上锁和解锁控制。例子（参考）：
好了，本文暂时讲到这里，还剩下std::try_lock，std::lock，std::call_once三个函数没有讲到，留在下一篇博客中讲吧;-)
