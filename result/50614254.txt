1、前言
　　今天在看代码时，遇到offsetof和container_of两个宏，觉得很有意思，功能很强大。offsetof是用来判断结构体中成员的偏移位置，container_of宏用来根据成员的地址来获取结构体的地址。两个宏设计的很巧妙，&#20540;得学习。linux内核中有着两个宏的定义，并在链表结构中得到应用。不得不提一下linux内核中的链表，设计的如此之妙，只需要两个指针就搞定了。后续认真研究一下这个链表结构。
2、offsetof宏
　　使用offsetof宏需要包含stddef.h头文件，实例可以参考：http://www.cplusplus.com/reference/cstddef/offsetof/。
offsetof宏的定义如下：
　　巧妙之处在于将地址0强制转换为type类型的指针，从而定位到member在结构体中偏移位置。编译器认为0是一个有效的地址，从而认为0是type指针的起始地址。
3、container_of宏
　　使用container_of宏需要包含linux/kernel.h头文件，container_of宏的定义如下所示：
container_of宏分为两部分，
第一部分：consttypeof(((type*)0)-&gt;member)*__mptr=(ptr);
通过typeof定义一个member指针类型的指针变量__mptr，（即__mptr是指向member类型的指针），并将__mptr赋&#20540;为ptr。
第二部分：
(type*)((char*)__mptr-offsetof(type,member))，通过offsetof宏计算出member在type中的偏移，然后用member的实际地址__mptr减去偏移，得到type的起始地址，即指向type类型的指针。
第一部分的目的是为了将统一转换为member类型指针。
1、前言
　　今天在看代码时，遇到offsetof和container_of两个宏，觉得很有意思，功能很强大。offsetof是用来判断结构体中成员的偏移位置，container_of宏用来根据成员的地址来获取结构体的地址。两个宏设计的很巧妙，&#20540;得学习。linux内核中有着两个宏的定义，并在链表结构中得到应用。不得不提一下linux内核中的链表，设计的如此之妙，只需要两个指针就搞定了。后续认真研究一下这个链表结构。
2、offsetof宏
　　使用offsetof宏需要包含stddef.h头文件，实例可以参考：http://www.cplusplus.com/reference/cstddef/offsetof/。
offsetof宏的定义如下：
　　巧妙之处在于将地址0强制转换为type类型的指针，从而定位到member在结构体中偏移位置。编译器认为0是一个有效的地址，从而认为0是type指针的起始地址。
3、container_of宏
　　使用container_of宏需要包含linux/kernel.h头文件，container_of宏的定义如下所示：
container_of宏分为两部分，
第一部分：consttypeof(((type*)0)-&gt;member)*__mptr=(ptr);
通过typeof定义一个member指针类型的指针变量__mptr，（即__mptr是指向member类型的指针），并将__mptr赋&#20540;为ptr。
第二部分：
(type*)((char*)__mptr-offsetof(type,member))，通过offsetof宏计算出member在type中的偏移，然后用member的实际地址__mptr减去偏移，得到type的起始地址，即指向type类型的指针。
第一部分的目的是为了将统一转换为member类型指针。
