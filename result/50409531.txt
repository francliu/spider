前面两讲《C&#43;&#43;11并发指南二(std::thread详解)》，《C&#43;&#43;11
并发指南三(std::mutex详解)》分别介绍了std::thread和std::mutex，相信读者对C&#43;&#43;11中的多线程编程有了一个最基本的认识，本文将介绍C&#43;&#43;11标准中&lt;future&gt;头文件里面的类和相关函数。
&lt;future&gt;头文件中包含了以下几个类和函数：
promise对象可以保存某一类型T的&#20540;，该&#20540;可被future对象读取（可能在另外一个线程中），因此promise也提供了一种线程同步的手段。在promise对象构造时可以和一个共享状态（通常是std::future）相关联，并可以在相关联的共享状态(std::future)上保存一个类型为T的&#20540;。
可以通过get_future来获取与该promise对象相关联的future对象，调用该函数之后，两个对象共享相同的共享状态(sharedstate)
下面以一个简单的例子来说明上述关系
另外，std::promise的operator=没有拷贝语义，即std::promise普通的赋&#20540;操作被禁用，operator=只有move语义，所以std::promise对象是禁止拷贝的。
例子:
该函数返回一个与promise共享状态相关联的future。返回的future对象可以访问由promise对象设置在共享状态上的&#20540;或者某个异常对象。只能从promise共享状态获取一个future对象。在调用该函数之后，promise对象通常会在某个时间点准备好(设置一个&#20540;或者一个异常对象)，如果不设置&#20540;或者异常，promise对象在析构时会自动地设置一个future_error异常(broken_promise)来设置其自身的准备状态。上面的例子中已经提到了
get_future，此处不再重复。
设置共享状态的&#20540;，此后promise的共享状态标志变为ready.
为promise设置异常，此后promise的共享状态变标志变为ready，例子如下，线程1从终端接收一个整数，线程2将该整数打印出来，如果线程1接收一个非整数，则为promise设置一个异常(failbit)，线程2在std::future::get是抛出该异常。
设置共享状态的&#20540;，但是不将共享状态的标志设置为ready，当线程退出时该promise对象会自动设置为ready。如果某个std::future对象与该promise对象的共享状态相关联，并且该future正在调用get，则调用get的线程会被阻塞，当线程退出时，调用future::get的线程解除阻塞，同时get返回set_value_at_thread_exit所设置的&#20540;。注意，该函数已经设置了promise共享状态的&#20540;，如果在线程结束之前有其他设置或者修改共享状态的&#20540;的操作，则会抛出
future_error(promise_already_satisfied)。
交换promise的共享状态。
前面两讲《C&#43;&#43;11并发指南二(std::thread详解)》，《C&#43;&#43;11
并发指南三(std::mutex详解)》分别介绍了std::thread和std::mutex，相信读者对C&#43;&#43;11中的多线程编程有了一个最基本的认识，本文将介绍C&#43;&#43;11标准中&lt;future&gt;头文件里面的类和相关函数。
&lt;future&gt;头文件中包含了以下几个类和函数：
promise对象可以保存某一类型T的&#20540;，该&#20540;可被future对象读取（可能在另外一个线程中），因此promise也提供了一种线程同步的手段。在promise对象构造时可以和一个共享状态（通常是std::future）相关联，并可以在相关联的共享状态(std::future)上保存一个类型为T的&#20540;。
可以通过get_future来获取与该promise对象相关联的future对象，调用该函数之后，两个对象共享相同的共享状态(sharedstate)
下面以一个简单的例子来说明上述关系
另外，std::promise的operator=没有拷贝语义，即std::promise普通的赋&#20540;操作被禁用，operator=只有move语义，所以std::promise对象是禁止拷贝的。
例子:
该函数返回一个与promise共享状态相关联的future。返回的future对象可以访问由promise对象设置在共享状态上的&#20540;或者某个异常对象。只能从promise共享状态获取一个future对象。在调用该函数之后，promise对象通常会在某个时间点准备好(设置一个&#20540;或者一个异常对象)，如果不设置&#20540;或者异常，promise对象在析构时会自动地设置一个future_error异常(broken_promise)来设置其自身的准备状态。上面的例子中已经提到了
get_future，此处不再重复。
设置共享状态的&#20540;，此后promise的共享状态标志变为ready.
为promise设置异常，此后promise的共享状态变标志变为ready，例子如下，线程1从终端接收一个整数，线程2将该整数打印出来，如果线程1接收一个非整数，则为promise设置一个异常(failbit)，线程2在std::future::get是抛出该异常。
设置共享状态的&#20540;，但是不将共享状态的标志设置为ready，当线程退出时该promise对象会自动设置为ready。如果某个std::future对象与该promise对象的共享状态相关联，并且该future正在调用get，则调用get的线程会被阻塞，当线程退出时，调用future::get的线程解除阻塞，同时get返回set_value_at_thread_exit所设置的&#20540;。注意，该函数已经设置了promise共享状态的&#20540;，如果在线程结束之前有其他设置或者修改共享状态的&#20540;的操作，则会抛出
future_error(promise_already_satisfied)。
交换promise的共享状态。
