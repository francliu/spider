AdamDunkels的论文中提到，基于Contiki的protothread开发时要特别注意变量的生存周期，分配在栈中的自动变量，随着函数被多次返回与调用，它很容易带来错误。现在，通过分析几个实例程序来总结protothread中定义变量的规律。
如图1所示的程序用于打印当前的时钟&#20540;，可得到的结果总是一些错误&#20540;，用理解传统函数的&#30524;光来看很难发现错误的原因，查看下图2的程序清单就可以得到更清晰的答案。
在上述的分析中发现protothread的自动变量容易产生错误，那么定义成static的静态变量就可以解决该问题。确实，因为static变量的生存周期不受函数返回的影响，因此不会出错。
小结：static变量在protothread的整个执行周期内都是安全的。
虽然static变量在protothread是安全的，但它会占用过多内存。举例，如果N个protothread都要分配M大小临时变量，如果都定义成static类型，那么这些变量将占用N*M大小的内存；如果定义成自动变量，那么只需要M大小的内存。
图3的代码是对图1出错代码的更改，结合图4可以看出是正确的。为什么这次自动变量tClock使用正确呢？因为它的使用范围在一个执行流之内（函数没有返回）。
小结：protothread中自动变量的安全区域是在一个执行流内，即函数不能返回。
这个道理是很明显的，看看图2和图4的代码就知道：一个protothread程序会预编译成带switch()的函数结构，如果用户再使用switch()结构，那将是一个多么混乱的世界！不仅编译器会报警，可能出错；开发者也很难把握程序的执行流了。替代的办法是使用if()语句，毕竟它能实现和switch()一样的功能。
作者简介：
蒋俊，男，硕士研究生，现任长沙市锐米通信科技有限公司CEO。
从事通信研究与嵌入式开发10年，主攻微功率无线网络。
精通LoRa无线扩频通信，无线星型/树型/MESH网络设计；
通晓Contiki,Linux,uC/OS-II,OSAL等操作系统；
熟悉ARM,DSP,STM8,PIC,PC104等处理器；
擅长AD，RF等集成IC开发。
Web:
www.rimelink.com
EMail:
jiangjunjie_2005@126.com
QQ群：35212129
AdamDunkels的论文中提到，基于Contiki的protothread开发时要特别注意变量的生存周期，分配在栈中的自动变量，随着函数被多次返回与调用，它很容易带来错误。现在，通过分析几个实例程序来总结protothread中定义变量的规律。
如图1所示的程序用于打印当前的时钟&#20540;，可得到的结果总是一些错误&#20540;，用理解传统函数的&#30524;光来看很难发现错误的原因，查看下图2的程序清单就可以得到更清晰的答案。
在上述的分析中发现protothread的自动变量容易产生错误，那么定义成static的静态变量就可以解决该问题。确实，因为static变量的生存周期不受函数返回的影响，因此不会出错。
小结：static变量在protothread的整个执行周期内都是安全的。
虽然static变量在protothread是安全的，但它会占用过多内存。举例，如果N个protothread都要分配M大小临时变量，如果都定义成static类型，那么这些变量将占用N*M大小的内存；如果定义成自动变量，那么只需要M大小的内存。
图3的代码是对图1出错代码的更改，结合图4可以看出是正确的。为什么这次自动变量tClock使用正确呢？因为它的使用范围在一个执行流之内（函数没有返回）。
小结：protothread中自动变量的安全区域是在一个执行流内，即函数不能返回。
这个道理是很明显的，看看图2和图4的代码就知道：一个protothread程序会预编译成带switch()的函数结构，如果用户再使用switch()结构，那将是一个多么混乱的世界！不仅编译器会报警，可能出错；开发者也很难把握程序的执行流了。替代的办法是使用if()语句，毕竟它能实现和switch()一样的功能。
作者简介：
蒋俊，男，硕士研究生，现任长沙市锐米通信科技有限公司CEO。
从事通信研究与嵌入式开发10年，主攻微功率无线网络。
精通LoRa无线扩频通信，无线星型/树型/MESH网络设计；
通晓Contiki,Linux,uC/OS-II,OSAL等操作系统；
熟悉ARM,DSP,STM8,PIC,PC104等处理器；
擅长AD，RF等集成IC开发。
Web:
www.rimelink.com
EMail:
jiangjunjie_2005@126.com
QQ群：35212129
