Designastackthatsupportspush,pop,top,andretrievingtheminimumelementinconstanttime.
solution:
structNode{





intval;





intmin;





Node*next;





Node(intx):val(x),next(NULL){}

};

classMinStack{




Node*ntop=NULL;




public:








voidpush(intx){












if(ntop==NULL)












{
















ntop=newNode(x);
















ntop-&gt;min=x;












}












else












{
















Node*temp=newNode(x);
















temp-&gt;next=ntop;
















ntop=temp;
















ntop-&gt;min=ntop-&gt;next-&gt;min&gt;x?x:ntop-&gt;next-&gt;min;












}








}














voidpop(){












if(ntop==NULL)return;












ntop=ntop-&gt;next;








}














inttop(){












if(ntop==NULL)return0;












returnntop-&gt;val;








}














intgetMin(){












if(ntop==NULL)return0;












returnntop-&gt;min;








}

};
Designastackthatsupportspush,pop,top,andretrievingtheminimumelementinconstanttime.
solution:
structNode{





intval;





intmin;





Node*next;





Node(intx):val(x),next(NULL){}

};

classMinStack{




Node*ntop=NULL;




public:








voidpush(intx){












if(ntop==NULL)












{
















ntop=newNode(x);
















ntop-&gt;min=x;












}












else












{
















Node*temp=newNode(x);
















temp-&gt;next=ntop;
















ntop=temp;
















ntop-&gt;min=ntop-&gt;next-&gt;min&gt;x?x:ntop-&gt;next-&gt;min;












}








}














voidpop(){












if(ntop==NULL)return;












ntop=ntop-&gt;next;








}














inttop(){












if(ntop==NULL)return0;












returnntop-&gt;val;








}














intgetMin(){












if(ntop==NULL)return0;












returnntop-&gt;min;








}

};
