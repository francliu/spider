一、set和multiset基础
set和multiset会根据特定的排序准则，自动将元素进行排序。不同的是后者允许元素重复而前者不允许。
需要包含头文件：
#include&lt;set&gt;
set和multiset都是定义在std空间里的类模板：


所谓排序准则，必须定义strictweakordering，其意义如下：
1、必须使反对称的。
对operator&lt;而言，如果x&lt;y为真，则y&lt;x为假。
2、必须使可传递的。
对operator&lt;而言，如果x&lt;y为真，且y&lt;z为真，则x&lt;z为真。
3、必须是非自反的。
对operator&lt;而言，x&lt;x永远为假。
因为上面的这些特性，排序准则可以用于相等性检验，就是说，如果两个元素都不小于对方，则它们相等。

二、set和multiset的功能
和所有关联式容器类&#20284;，通常使用平衡二叉树完成。事实上，set和multiset通常以红黑树实作而成。
自动排序的优点是使得搜寻元素时具有良好的性能，具有对数时间复杂度。但是造成的一个缺点就是：
不能直接改变元素&#20540;。因为这样会打乱原有的顺序。
改变元素&#20540;的方法是：先删除旧元素，再插入新元素。
存取元素只能通过迭代器，从迭代器的角度看，元素&#20540;是常数。

三、操作函数
构造函数和析构函数
set的形式可以是：
有两种方式可以定义排序准则：
1、以template参数定义：


程序实例：


2、以构造函数参数定义。
这种情况下，同一个型别可以运用不同的排序准则，而排序准则的初始&#20540;或状态也可以不同。如果执行期才获得排序准则，而且需要用到不同的排序准则，这种方式可以派上用场。
程序实例：





非变动性操作
注意：元素比较操作只能用于型别相同的容器。
特殊的搜寻函数

赋&#20540;
赋&#20540;操作两端的容器必须具有相同的型别，但是比较准则本身可以不同，但是其型别必须相同。如果比较准则的不同，准则本身也会被赋&#20540;或交换。
迭代器相关函数
元素的插入和删除
注意：插入函数的返回&#20540;不完全相同。
set提供的插入函数：




第一个元素返回新元素的位置，或返回现存的同&#20540;元素的位置。第二个元素表示插入是否成功。
set的第二个insert函数，如果插入失败，就只返回重复元素的位置！


但是，所有拥有位置提示参数的插入函数的返回&#20540;型别是相同的。这样就确保了至少有了一个通用型的插入函数，在各种容器中有共通接口。

注意：还有一个返回&#20540;不同的情况是：作用于序列式容器和关联式容器的erase()函数：
序列式容器的erase()函数：






注意：s1和s2有不同的排序准则，所以他们的型别不同，不能直接进行相互赋&#20540;或比较。
运行结果：
一、set和multiset基础
set和multiset会根据特定的排序准则，自动将元素进行排序。不同的是后者允许元素重复而前者不允许。
需要包含头文件：
#include&lt;set&gt;
set和multiset都是定义在std空间里的类模板：


所谓排序准则，必须定义strictweakordering，其意义如下：
1、必须使反对称的。
对operator&lt;而言，如果x&lt;y为真，则y&lt;x为假。
2、必须使可传递的。
对operator&lt;而言，如果x&lt;y为真，且y&lt;z为真，则x&lt;z为真。
3、必须是非自反的。
对operator&lt;而言，x&lt;x永远为假。
因为上面的这些特性，排序准则可以用于相等性检验，就是说，如果两个元素都不小于对方，则它们相等。

二、set和multiset的功能
和所有关联式容器类&#20284;，通常使用平衡二叉树完成。事实上，set和multiset通常以红黑树实作而成。
自动排序的优点是使得搜寻元素时具有良好的性能，具有对数时间复杂度。但是造成的一个缺点就是：
不能直接改变元素&#20540;。因为这样会打乱原有的顺序。
改变元素&#20540;的方法是：先删除旧元素，再插入新元素。
存取元素只能通过迭代器，从迭代器的角度看，元素&#20540;是常数。

三、操作函数
构造函数和析构函数
set的形式可以是：
有两种方式可以定义排序准则：
1、以template参数定义：


程序实例：


2、以构造函数参数定义。
这种情况下，同一个型别可以运用不同的排序准则，而排序准则的初始&#20540;或状态也可以不同。如果执行期才获得排序准则，而且需要用到不同的排序准则，这种方式可以派上用场。
程序实例：





非变动性操作
注意：元素比较操作只能用于型别相同的容器。
特殊的搜寻函数

赋&#20540;
赋&#20540;操作两端的容器必须具有相同的型别，但是比较准则本身可以不同，但是其型别必须相同。如果比较准则的不同，准则本身也会被赋&#20540;或交换。
迭代器相关函数
元素的插入和删除
注意：插入函数的返回&#20540;不完全相同。
set提供的插入函数：




第一个元素返回新元素的位置，或返回现存的同&#20540;元素的位置。第二个元素表示插入是否成功。
set的第二个insert函数，如果插入失败，就只返回重复元素的位置！


但是，所有拥有位置提示参数的插入函数的返回&#20540;型别是相同的。这样就确保了至少有了一个通用型的插入函数，在各种容器中有共通接口。

注意：还有一个返回&#20540;不同的情况是：作用于序列式容器和关联式容器的erase()函数：
序列式容器的erase()函数：






注意：s1和s2有不同的排序准则，所以他们的型别不同，不能直接进行相互赋&#20540;或比较。
运行结果：
一、set和multiset基础
set和multiset会根据特定的排序准则，自动将元素进行排序。不同的是后者允许元素重复而前者不允许。
需要包含头文件：
#include&lt;set&gt;
set和multiset都是定义在std空间里的类模板：


所谓排序准则，必须定义strictweakordering，其意义如下：
1、必须使反对称的。
对operator&lt;而言，如果x&lt;y为真，则y&lt;x为假。
2、必须使可传递的。
对operator&lt;而言，如果x&lt;y为真，且y&lt;z为真，则x&lt;z为真。
3、必须是非自反的。
对operator&lt;而言，x&lt;x永远为假。
因为上面的这些特性，排序准则可以用于相等性检验，就是说，如果两个元素都不小于对方，则它们相等。

二、set和multiset的功能
和所有关联式容器类&#20284;，通常使用平衡二叉树完成。事实上，set和multiset通常以红黑树实作而成。
自动排序的优点是使得搜寻元素时具有良好的性能，具有对数时间复杂度。但是造成的一个缺点就是：
不能直接改变元素&#20540;。因为这样会打乱原有的顺序。
改变元素&#20540;的方法是：先删除旧元素，再插入新元素。
存取元素只能通过迭代器，从迭代器的角度看，元素&#20540;是常数。

三、操作函数
构造函数和析构函数
set的形式可以是：
有两种方式可以定义排序准则：
1、以template参数定义：


程序实例：


2、以构造函数参数定义。
这种情况下，同一个型别可以运用不同的排序准则，而排序准则的初始&#20540;或状态也可以不同。如果执行期才获得排序准则，而且需要用到不同的排序准则，这种方式可以派上用场。
程序实例：





非变动性操作
注意：元素比较操作只能用于型别相同的容器。
特殊的搜寻函数

赋&#20540;
赋&#20540;操作两端的容器必须具有相同的型别，但是比较准则本身可以不同，但是其型别必须相同。如果比较准则的不同，准则本身也会被赋&#20540;或交换。
迭代器相关函数
元素的插入和删除
注意：插入函数的返回&#20540;不完全相同。
set提供的插入函数：




第一个元素返回新元素的位置，或返回现存的同&#20540;元素的位置。第二个元素表示插入是否成功。
set的第二个insert函数，如果插入失败，就只返回重复元素的位置！


但是，所有拥有位置提示参数的插入函数的返回&#20540;型别是相同的。这样就确保了至少有了一个通用型的插入函数，在各种容器中有共通接口。

注意：还有一个返回&#20540;不同的情况是：作用于序列式容器和关联式容器的erase()函数：
序列式容器的erase()函数：






注意：s1和s2有不同的排序准则，所以他们的型别不同，不能直接进行相互赋&#20540;或比较。
运行结果：
一、set和multiset基础
set和multiset会根据特定的排序准则，自动将元素进行排序。不同的是后者允许元素重复而前者不允许。
需要包含头文件：
#include&lt;set&gt;
set和multiset都是定义在std空间里的类模板：


所谓排序准则，必须定义strictweakordering，其意义如下：
1、必须使反对称的。
对operator&lt;而言，如果x&lt;y为真，则y&lt;x为假。
2、必须使可传递的。
对operator&lt;而言，如果x&lt;y为真，且y&lt;z为真，则x&lt;z为真。
3、必须是非自反的。
对operator&lt;而言，x&lt;x永远为假。
因为上面的这些特性，排序准则可以用于相等性检验，就是说，如果两个元素都不小于对方，则它们相等。

二、set和multiset的功能
和所有关联式容器类&#20284;，通常使用平衡二叉树完成。事实上，set和multiset通常以红黑树实作而成。
自动排序的优点是使得搜寻元素时具有良好的性能，具有对数时间复杂度。但是造成的一个缺点就是：
不能直接改变元素&#20540;。因为这样会打乱原有的顺序。
改变元素&#20540;的方法是：先删除旧元素，再插入新元素。
存取元素只能通过迭代器，从迭代器的角度看，元素&#20540;是常数。

三、操作函数
构造函数和析构函数
set的形式可以是：
有两种方式可以定义排序准则：
1、以template参数定义：


程序实例：


2、以构造函数参数定义。
这种情况下，同一个型别可以运用不同的排序准则，而排序准则的初始&#20540;或状态也可以不同。如果执行期才获得排序准则，而且需要用到不同的排序准则，这种方式可以派上用场。
程序实例：





非变动性操作
注意：元素比较操作只能用于型别相同的容器。
特殊的搜寻函数

赋&#20540;
赋&#20540;操作两端的容器必须具有相同的型别，但是比较准则本身可以不同，但是其型别必须相同。如果比较准则的不同，准则本身也会被赋&#20540;或交换。
迭代器相关函数
元素的插入和删除
注意：插入函数的返回&#20540;不完全相同。
set提供的插入函数：




第一个元素返回新元素的位置，或返回现存的同&#20540;元素的位置。第二个元素表示插入是否成功。
set的第二个insert函数，如果插入失败，就只返回重复元素的位置！


但是，所有拥有位置提示参数的插入函数的返回&#20540;型别是相同的。这样就确保了至少有了一个通用型的插入函数，在各种容器中有共通接口。

注意：还有一个返回&#20540;不同的情况是：作用于序列式容器和关联式容器的erase()函数：
序列式容器的erase()函数：






注意：s1和s2有不同的排序准则，所以他们的型别不同，不能直接进行相互赋&#20540;或比较。
运行结果：
