http://hi.baidu.com/%B1%D5%C4%BF%B3%C9%B7%F0/blog/item/e7284ef16bcec3c70a46e05e.html
select函数用于在非阻塞中，当一个套接字或一组套接字有信号时通知你，系统提供select函数来实现多路复用输入/输出模型，原型：
rdset,wrset,exset分别对应于需要检测的可读文件描述符的集合，可写文件描述符的集合及异常文件描述符的集合。
structtimeval结构用于描述一段时间长度，如果在这个时间内，需要监视的描述符没有事件发生则函数返回，返回&#20540;为0。




fd_set（它比较重要所以先介绍一下）是一组文件描述字(fd)的集合，它用一位来表示一个fd（下面会仔细介绍），对于fd_set类型通过下面四个宏来操作：





FD_ZERO(fd_set*fdset);将指定的文件描述符集清空，在对文件描述符集合进行设置前，必须对其进行初始化，如果不清空，由于在系统分配内存空间后，通常并不作清空处理，所以结果是不可知的。





FD_SET(fd_set*fdset);用于在文件描述符集合中增加一个新的文件描述符。





FD_CLR(fd_set*fdset);用于在文件描述符集合中删除一个文件描述符。





FD_ISSET(intfd,fd_set*fdset);用于测试指定的文件描述符是否在该集合中。
过去，一个fd_set通常只能包含&lt;32的fd（文件描述字），因为fd_set其实只用了一个32位矢量来表示fd；现在,UNIX系统通常会在头文件&lt;sys/select.h&gt;中定义常量FD_SETSIZE，它是数据类型fd_set的描述字数量，其&#20540;通常是1024，这样就能表示&lt;1024的fd。根据fd_set的位矢量实现，我们可以重新理解操作fd_set的四个宏：
2、select函数的接口比较简单：

测试指定的fd可读？可写？有异常条件待处理？





参数：




nfds







需要检查的文件描述字个数（即检查到fd_set的第几位），数&#20540;应该比三组fd_set中所含的最大fd&#20540;更大，一般设为三组fd_set中所含的最大fd&#20540;加1（如在readset,writeset,exceptset中所含最大的fd为5，则nfds=6，因为fd是从0开始的）。设这个&#20540;是为提高效率，使函数不必检查fd_set的所有1024位。




readset






用来检查可读性的一组文件描述字。




writeset




用来检查可写性的一组文件描述字。




exceptset




用来检查是否有异常条件出现的文件描述字。(注：错误不包括在异常条件之内)




timeout




用于描述一段时间长度，如果在这个时间内，需要监视的描述符没有事件发生则函数返回，返回&#20540;为0。




有三种可能：






1.timeout=NULL（阻塞：select将一直被阻塞，直到某个文件描述符上发生了事件）






2.timeout所指向的结构设为非零时间（等待固定时间：如果在指定的时间段里有事件发生或者时间耗尽，函数均返回）






3.timeout所指向的结构，时间设为0（非阻塞：仅检测描述符集合的状态，然后立即返回，并不等待外部事件的发生）
返回&#20540;：








返回对应位仍然为1的fd的总数。
Remarks：




三组fd_set均将某些fd位置0，只有那些可读，可写以及有异常条件待处理的fd位仍然为1。
举个例子，比如recv(),

在没有数据到来调用它的时候,你的线程将被阻塞,如果数据一直不来,你的线程就要阻塞很久.这样显然不好.
所以采用select来查看套节字是否可读(也就是是否有数据读了)



步骤如下——
（1）执行fd_setset;FD_ZERO(&amp;set);则set用位表示是0000,0000。




（2）若fd＝5,执行FD_SET(fd,&amp;set);后set变为0001,0000(第5位置为1)




（3）若再加入fd＝2，fd=1,则set变为0001,0011




（4）执行select(6,&amp;set,0,0,0)阻塞等待




（5）若fd=1,fd=2上都发生可读事件，则select返回，此时set变为0000,0011。注意：没有事件发生的fd=5被清空。
基于上面的讨论，可以轻松得出select模型的特点：




（1)可监控的文件描述符个数取决与sizeof(fd_set)的&#20540;。我这边服务器上sizeof(fd_set)＝512，每bit表示一个文件描述符，则我服务器上支持的最大文件描述符是512*8=4096。据说可调，另有说虽然可调，但调整上限受于编译内核时的变量&#20540;。本人对调整fd_set的大小不太感兴趣，参考http://www.cppblog.com
/CppExplore/archive/2008/03/21/45061.html中的模型2（1）可以有效突破select可监控的文件描述符上限。




（2）将fd加入select监控集的同时，还要再使用一个数据结构array保存放到select监控集中的fd，一是用于再select返回后，array作为源数据和fd_set进行FD_ISSET判断。二是select返回后会把以前加入的但并无事件发生的fd清空，则每次开始select前都要重新从array取得fd逐一加入（FD_ZERO最先），扫描array的同时取得fd最大&#20540;maxfd，用于select的第一个参数。




（3）可见select模型必须在select前循环array（加fd，取maxfd），select返回后循环array（FD_ISSET判断是否有时间发生）。




下面给一个伪码说明基本select模型的服务器模型：
以下是一个测试单个文件描述字可读性的例子：
http://hi.baidu.com/%B1%D5%C4%BF%B3%C9%B7%F0/blog/item/e7284ef16bcec3c70a46e05e.html
select函数用于在非阻塞中，当一个套接字或一组套接字有信号时通知你，系统提供select函数来实现多路复用输入/输出模型，原型：
rdset,wrset,exset分别对应于需要检测的可读文件描述符的集合，可写文件描述符的集合及异常文件描述符的集合。
structtimeval结构用于描述一段时间长度，如果在这个时间内，需要监视的描述符没有事件发生则函数返回，返回&#20540;为0。




fd_set（它比较重要所以先介绍一下）是一组文件描述字(fd)的集合，它用一位来表示一个fd（下面会仔细介绍），对于fd_set类型通过下面四个宏来操作：





FD_ZERO(fd_set*fdset);将指定的文件描述符集清空，在对文件描述符集合进行设置前，必须对其进行初始化，如果不清空，由于在系统分配内存空间后，通常并不作清空处理，所以结果是不可知的。





FD_SET(fd_set*fdset);用于在文件描述符集合中增加一个新的文件描述符。





FD_CLR(fd_set*fdset);用于在文件描述符集合中删除一个文件描述符。





FD_ISSET(intfd,fd_set*fdset);用于测试指定的文件描述符是否在该集合中。
过去，一个fd_set通常只能包含&lt;32的fd（文件描述字），因为fd_set其实只用了一个32位矢量来表示fd；现在,UNIX系统通常会在头文件&lt;sys/select.h&gt;中定义常量FD_SETSIZE，它是数据类型fd_set的描述字数量，其&#20540;通常是1024，这样就能表示&lt;1024的fd。根据fd_set的位矢量实现，我们可以重新理解操作fd_set的四个宏：
2、select函数的接口比较简单：

测试指定的fd可读？可写？有异常条件待处理？





参数：




nfds







需要检查的文件描述字个数（即检查到fd_set的第几位），数&#20540;应该比三组fd_set中所含的最大fd&#20540;更大，一般设为三组fd_set中所含的最大fd&#20540;加1（如在readset,writeset,exceptset中所含最大的fd为5，则nfds=6，因为fd是从0开始的）。设这个&#20540;是为提高效率，使函数不必检查fd_set的所有1024位。




readset






用来检查可读性的一组文件描述字。




writeset




用来检查可写性的一组文件描述字。




exceptset




用来检查是否有异常条件出现的文件描述字。(注：错误不包括在异常条件之内)




timeout




用于描述一段时间长度，如果在这个时间内，需要监视的描述符没有事件发生则函数返回，返回&#20540;为0。




有三种可能：






1.timeout=NULL（阻塞：select将一直被阻塞，直到某个文件描述符上发生了事件）






2.timeout所指向的结构设为非零时间（等待固定时间：如果在指定的时间段里有事件发生或者时间耗尽，函数均返回）






3.timeout所指向的结构，时间设为0（非阻塞：仅检测描述符集合的状态，然后立即返回，并不等待外部事件的发生）
返回&#20540;：








返回对应位仍然为1的fd的总数。
Remarks：




三组fd_set均将某些fd位置0，只有那些可读，可写以及有异常条件待处理的fd位仍然为1。
举个例子，比如recv(),

在没有数据到来调用它的时候,你的线程将被阻塞,如果数据一直不来,你的线程就要阻塞很久.这样显然不好.
所以采用select来查看套节字是否可读(也就是是否有数据读了)



步骤如下——
（1）执行fd_setset;FD_ZERO(&amp;set);则set用位表示是0000,0000。




（2）若fd＝5,执行FD_SET(fd,&amp;set);后set变为0001,0000(第5位置为1)




（3）若再加入fd＝2，fd=1,则set变为0001,0011




（4）执行select(6,&amp;set,0,0,0)阻塞等待




（5）若fd=1,fd=2上都发生可读事件，则select返回，此时set变为0000,0011。注意：没有事件发生的fd=5被清空。
基于上面的讨论，可以轻松得出select模型的特点：




（1)可监控的文件描述符个数取决与sizeof(fd_set)的&#20540;。我这边服务器上sizeof(fd_set)＝512，每bit表示一个文件描述符，则我服务器上支持的最大文件描述符是512*8=4096。据说可调，另有说虽然可调，但调整上限受于编译内核时的变量&#20540;。本人对调整fd_set的大小不太感兴趣，参考http://www.cppblog.com
/CppExplore/archive/2008/03/21/45061.html中的模型2（1）可以有效突破select可监控的文件描述符上限。




（2）将fd加入select监控集的同时，还要再使用一个数据结构array保存放到select监控集中的fd，一是用于再select返回后，array作为源数据和fd_set进行FD_ISSET判断。二是select返回后会把以前加入的但并无事件发生的fd清空，则每次开始select前都要重新从array取得fd逐一加入（FD_ZERO最先），扫描array的同时取得fd最大&#20540;maxfd，用于select的第一个参数。




（3）可见select模型必须在select前循环array（加fd，取maxfd），select返回后循环array（FD_ISSET判断是否有时间发生）。




下面给一个伪码说明基本select模型的服务器模型：
以下是一个测试单个文件描述字可读性的例子：
