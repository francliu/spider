之前写了
设计模式系列目录
今天说一下工厂方法模式：
定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个。工厂方法让类把实例化推迟到子类
所谓的决定并不是批模式允许子类本身在运行时做决定，而是指在编写创建者类时，不需知道创建的产品是哪一下，选择了使用
哪个子类，就决定了实际创建的产品是什么。



让我们来看一下依赖关系

我们会看到
Creator和所有的产品（OneProduct、TwoProduct...）都依赖了Product.这是依赖倒置原则：要依赖抽象，不要依赖具体类
也就是说不能让具体产品去依赖Creator，不管是产品还是Creator都应该依赖于抽象
就用这个原则我们要尽量做到
1变量不可以持有具体类的引用（如果使用new就会有具体类的引用。你可以改用工厂来避开这样的做法）
2不要让类派生自具体类（派生自一个接口）
3不要覆盖基类中已实现的方法
但在实际编程时不可能完全遵守这几条，我们只要尽量做就可以了

c&#43;&#43;代码
product
调用

之前写了
设计模式系列目录
今天说一下工厂方法模式：
定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个。工厂方法让类把实例化推迟到子类
所谓的决定并不是批模式允许子类本身在运行时做决定，而是指在编写创建者类时，不需知道创建的产品是哪一下，选择了使用
哪个子类，就决定了实际创建的产品是什么。



让我们来看一下依赖关系

我们会看到
Creator和所有的产品（OneProduct、TwoProduct...）都依赖了Product.这是依赖倒置原则：要依赖抽象，不要依赖具体类
也就是说不能让具体产品去依赖Creator，不管是产品还是Creator都应该依赖于抽象
就用这个原则我们要尽量做到
1变量不可以持有具体类的引用（如果使用new就会有具体类的引用。你可以改用工厂来避开这样的做法）
2不要让类派生自具体类（派生自一个接口）
3不要覆盖基类中已实现的方法
但在实际编程时不可能完全遵守这几条，我们只要尽量做就可以了

c&#43;&#43;代码
product
调用

