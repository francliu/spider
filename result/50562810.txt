作者总结：
1.纯虚函数声明如下：virtualReturnTypeFunctionName(Parameter)=0;
纯虚函数一定没有定义，纯虚函数用来规范派生类的行为，即接口。包含纯虚函数
的类是抽象类，抽象类不能定义实例，但可以声明指向实现该抽象类的具体类的指针或引用。
2.虚函数声明如下：virtualReturnTypeFunctionName(Parameter)；
虚函数必须实现，如果不实现，编译器将报错，错误提示为：
errorLNK****:unresolvedexternalsymbol&quot;public:virtualvoid__thiscall
ClassName::virtualFunctionName(void)&quot;
3.对于虚函数来说，父类和子类都有各自的版本。由多态方式调用的时候动态绑定。
4.实现了纯虚函数的子类，该纯虚函数在子类中就编程了虚函数，子类的子类即孙子类可以覆盖
该虚函数，由多态方式调用的时候动态绑定。
5.虚函数是C&#43;&#43;中用于实现多态(polymorphism)的机制。核心理念就是通过基类访问派生类定义的
函数
6在有动态分配堆上内存的时候，析构函数必须是虚函数，但没有必要是纯虚的。
7友元不是成员函数，只有成员函数才可以是虚拟的，因此友元不能是虚拟函数。但可以通过让友
元函数调用虚拟成员函数来解决友元的虚拟问题。
8析构函数应当是虚函数，将调用相应对象类型的析构函数，因此，如果指针指向的是子类对
象，将调用子类的析构函数，然后自动调用基类的析构函数。
例如：
Father*fp=newSon();//合法的，无论父类是否为抽象类，即使是具体类，也可以指向子类。
...
delete*fp;//是调用~Father()还是~Son()???
如果使用默认的静态联编，则delete语句调用~Father()析构，这将释放由Son对象中的Father部分指
向的内存，但不会释放新的类成员指向的内存。
但如果析构函数是虚拟的，则上面代码会先调用~Son()释放由Son组件指向的内容，然后自动调用
~Father()析构函数来释放由Father组件指向的内存。
这意味着：即使基类不需要显示析构函数提供服务，也不应该依赖于默认构造函数，而应当提供虚拟析
构函数，即使他不执行任何操作：virtual~BaseClass(){};
注：多态方式调用是指用父类的指针或引用来指向子类的实例后，用父类的指针或引用来调用虚函数.
即：如果使用指向对象的引用或指针来调用虚拟方法，程序将使用为对象类型定义的方法，而
不使用为引用或指针类型定义的方法。也称作动态联编或晚期绑定。
参考引用
&lt;C&#43;&#43;实践系列&gt;C&#43;&#43;中的虚函数(virtualfunction)

作者：张笑猛

原文出处：http://objects.nease.net/



1.简介
假设我们有下面的类层次：
classA

{

public:

virtualvoidfoo(){cout&lt;&lt;&quot;A::foo()iscalled&quot;&lt;&lt;endl;}

};


classB:publicA

{

public:

virtualvoidfoo(){cout&lt;&lt;&quot;B::foo()iscalled&quot;&lt;&lt;endl;}

};
那么，在使用的时候，我们可以：
A*a=newB();

a-&gt;foo();//在这里，a虽然是指向A的指针，但是被调用的函数(foo)却是B的!
这个例子是虚函数的一个典型应用，通过这个例子，也许你就对虚函数有了一些概念。它虚就虚在所谓“推迟联编”或者“动态联编”上，一个类函数的调用并不是在编译时刻被确定的，而是在运行时刻被确定的。由于编写代码的时候并不能确定被调用的是基类的函数还是哪个派生类的函数，所以被成为“虚”函数。
虚函数只能借助于指针或者引用来达到多态的效果，如果是下面这样的代码，则虽然是虚函数，但它不是多态的：
classA

{

public:

virtualvoidfoo();

};


classB:publicA

{

virtualvoidfoo();

};


voidbar()

{

Aa;

a.foo();//A::foo()被调用

}
在了解了虚函数的意思之后，再考虑什么是多态就很容易了。仍然针对上面的类层次，但是使用的方法变的复杂了一些：
voidbar(A*a)

{

a-&gt;foo();//被调用的是A::foo()还是B::foo()？

}


因为foo()是个虚函数，所以在bar这个函数中，只根据这段代码，无从确定这里被调用的是A::foo()还是B::foo()，但是可以肯定的说：如果a指向的是A类的实例，则A::foo()被调用，如果a指向的是B类的实例，则B::foo()被调用。
这种同一代码可以产生不同效果的特点，被称为“多态”。
多态这么神奇，但是能用来做什么呢？这个命题我难以用一两句话概括，一般的C&#43;&#43;教程（或者其它面向对象语言的教程）都用一个画图的例子来展示多态的用途，我就不再重复这个例子了，如果你不知道这个例子，随便找本书应该都有介绍。我试图从一个抽象的角度描述一下，回头再结合那个画图的例子，也许你就更容易理解。
在面向对象的编程中，首先会针对数据进行抽象（确定基类）和继承（确定派生类），构成类层次。这个类层次的使用者在使用它们的时候，如果仍然在需要基类的时候写针对基类的代码，在需要派生类的时候写针对派生类的代码，就等于类层次完全暴露在使用者面前。如果这个类层次有任何的改变（增加了新类），都需要使用者“知道”（针对新类写代码）。这样就增加了类层次与其使用者之间的耦合，有人把这种情况列为程序中的“badsmell”之一。
多态可以使程序员脱离这种窘境。再回头看看1.1中的例子，bar()作为A-B这个类层次的使用者，它并不知道这个类层次中有多少个类，每个类都叫什么，但是一样可以很好的工作，当有一个C类从A类派生出来后，bar()也不需要“知道”（修改）。这完全归功于多态--编译器针对虚函数产生了可以在运行时刻确定被调用函数的代码。
编译器是如何针对虚函数产生可以再运行时刻确定被调用函数的代码呢？也就是说，虚函数实际上是如何被编译器处理的呢？Lippman在深度探索C&#43;&#43;对象模型[1]中的不同章节讲到了几种方式，这里把“标准的”方式简单介绍一下。
我所说的“标准”方式，也就是所谓的“VTABLE”机制。编译器发现一个类中有被声明为virtual的函数，就会为其搞一个虚函数表，也就是VTABLE。VTABLE实际上是一个函数指针的数组，每个虚函数占用这个数组的一个slot。一个类只有一个VTABLE，不管它有多少个实例。派生类有自己的VTABLE，但是派生类的VTABLE与基类的VTABLE有相同的函数排列顺序，同名的虚函数被放在两个数组的相同位置上。在创建类实例的时候，编译器还会在每个实例的内存布局中增加一个vptr字段，该字段指向本类的VTABLE。通过这些手段，编译器在看到一个虚函数调用的时候，就会将这个调用改写，针对1.1中的例子：
voidbar(A*a)

{

a-&gt;foo();

}


会被改写为：
voidbar(A*a)

{

(a-&gt;vptr[1])();

}


因为派生类和基类的foo()函数具有相同的VTABLE索引，而他们的vptr又指向不同的VTABLE，因此通过这样的方法可以在运行时刻决定调用哪个foo()函数。
虽然实际情况远非这么简单，但是基本原理大致如此。
虚函数总是在派生类中被改写，这种改写被称为“override”。我经常混淆“overload”和“override”这两个单词。但是随着各类C&#43;&#43;的书越来越多，后来的程序员也许不会再犯我犯过的错误了。但是我打算澄清一下：
虚函数的标志是“virtual”关键字。
考虑下面的类层次：
classA

{

public:

virtualvoidfoo();

};


classB:publicA

{

public:

voidfoo();//没有virtual关键字!

};


classC:publicB//从B继承，不是从A继承！

{

public:

voidfoo();//也没有virtual关键字！

};
这种情况下，B::foo()是虚函数，C::foo()也同样是虚函数。因此，可以说，基类声明的虚函数，在派生类中也是虚函数，即使不再使用virtual关键字。
如下声明表示一个函数为纯虚函数：
classA

{

public:

virtualvoidfoo()=0;//=0标志一个虚函数为纯虚函数

};
一个函数声明为纯虚后，纯虚函数的意思是：我是一个抽象类！不要把我实例化！纯虚函数用来规范派生类的行为，实际上就是所谓的“接口”。它告诉使用者，我的派生类都会有这个函数。
析构函数也可以是虚的，甚至是纯虚的。例如：
classA

{

public:

virtual~A()=0;//纯虚析构函数

};
当一个类打算被用作其它类的基类时，它的析构函数必须是虚的。考虑下面的例子：
classA

{

public:

A(){ptra_=newchar[10];}

~A(){delete[]ptra_;}//非虚析构函数

private:

char*ptra_;

};


classB:publicA

{

public:

B(){ptrb_=newchar[20];}

~B(){delete[]ptrb_;}

private:

char*ptrb_;

};


voidfoo()

{

A*a=newB;

deletea;

}
在这个例子中，程序也许不会象你想象的那样运行，在执行deletea的时候，实际上只有A::~A()被调用了，而B类的析构函数并没有被调用！这是否有点儿可怕？
如果将上面A::~A()改为virtual，就可以保证B::~B()也在deletea的时候被调用了。因此基类的析构函数都必须是virtual的。
纯虚的析构函数并没有什么作用，是虚的就够了。通常只有在希望将一个类变成抽象类（不能实例化的类），而这个类又没有合适的函数可以被纯虚化的时候，可以使用纯虚的析构函数来达到目的。
构造函数不能是虚的。
考虑下面的例子：
classA

{

public:

voidfoo(){bar();}

private:

virtualvoidbar(){...}

};


classB:publicA

{

private:

virtualvoidbar(){...}

};


在这个例子中，虽然bar()在A类中是private的，但是仍然可以出现在派生类中，并仍然可以与public或者protected的虚函数一样产生多态的效果。并不会因为它是private的，就发生A::foo()不能访问B::bar()的情况，也不会发生B::bar()对A::bar()的override不起作用的情况。
这种写法的语意是：A告诉B，你最好override我的bar()函数，但是你不要管它如何使用，也不要自己调用这个函数。
一个类的虚函数在它自己的构造函数和析构函数中被调用的时候，它们就变成普通函数了，不“虚”了。也就是说不能在构造函数和析构函数中让自己“多态”。例如：
classA

{

public:

A(){foo();}//在这里，无论如何都是A::foo()被调用！

~A(){foo();}//同上

virtualvoidfoo();

};


classB:publicA

{

public:

virtualvoidfoo();

};


voidbar()

{

A*a=newB;

deletea;

}


如果你希望deletea的时候，会导致B::foo()被调用，那么你就错了。同样，在newB的时候，A的构造函数被调用，但是在A的构造函数中，被调用的是A::foo()而不是B::foo()。
在你设计一个基类的时候，如果发现一个函数需要在派生类里有不同的表现，那么它就应该是虚的。从设计的角度讲，出现在基类中的虚函数是接口，出现在派生类中的虚函数是接口的具体实现。通过这样的方法，就可以将对象的行为抽象化。
[1]深度探索C&#43;&#43;对象模型，StanleyB.Lippman，侯捷译
[2]DesignPatterns,ElementsofReusableObject-OrientedSoftware,GOF
作者总结：
1.纯虚函数声明如下：virtualReturnTypeFunctionName(Parameter)=0;
纯虚函数一定没有定义，纯虚函数用来规范派生类的行为，即接口。包含纯虚函数
的类是抽象类，抽象类不能定义实例，但可以声明指向实现该抽象类的具体类的指针或引用。
2.虚函数声明如下：virtualReturnTypeFunctionName(Parameter)；
虚函数必须实现，如果不实现，编译器将报错，错误提示为：
errorLNK****:unresolvedexternalsymbol&quot;public:virtualvoid__thiscall
ClassName::virtualFunctionName(void)&quot;
3.对于虚函数来说，父类和子类都有各自的版本。由多态方式调用的时候动态绑定。
4.实现了纯虚函数的子类，该纯虚函数在子类中就编程了虚函数，子类的子类即孙子类可以覆盖
该虚函数，由多态方式调用的时候动态绑定。
5.虚函数是C&#43;&#43;中用于实现多态(polymorphism)的机制。核心理念就是通过基类访问派生类定义的
函数
6在有动态分配堆上内存的时候，析构函数必须是虚函数，但没有必要是纯虚的。
7友元不是成员函数，只有成员函数才可以是虚拟的，因此友元不能是虚拟函数。但可以通过让友
元函数调用虚拟成员函数来解决友元的虚拟问题。
8析构函数应当是虚函数，将调用相应对象类型的析构函数，因此，如果指针指向的是子类对
象，将调用子类的析构函数，然后自动调用基类的析构函数。
例如：
Father*fp=newSon();//合法的，无论父类是否为抽象类，即使是具体类，也可以指向子类。
...
delete*fp;//是调用~Father()还是~Son()???
如果使用默认的静态联编，则delete语句调用~Father()析构，这将释放由Son对象中的Father部分指
向的内存，但不会释放新的类成员指向的内存。
但如果析构函数是虚拟的，则上面代码会先调用~Son()释放由Son组件指向的内容，然后自动调用
~Father()析构函数来释放由Father组件指向的内存。
这意味着：即使基类不需要显示析构函数提供服务，也不应该依赖于默认构造函数，而应当提供虚拟析
构函数，即使他不执行任何操作：virtual~BaseClass(){};
注：多态方式调用是指用父类的指针或引用来指向子类的实例后，用父类的指针或引用来调用虚函数.
即：如果使用指向对象的引用或指针来调用虚拟方法，程序将使用为对象类型定义的方法，而
不使用为引用或指针类型定义的方法。也称作动态联编或晚期绑定。
参考引用
&lt;C&#43;&#43;实践系列&gt;C&#43;&#43;中的虚函数(virtualfunction)

作者：张笑猛

原文出处：http://objects.nease.net/



1.简介
假设我们有下面的类层次：
classA

{

public:

virtualvoidfoo(){cout&lt;&lt;&quot;A::foo()iscalled&quot;&lt;&lt;endl;}

};


classB:publicA

{

public:

virtualvoidfoo(){cout&lt;&lt;&quot;B::foo()iscalled&quot;&lt;&lt;endl;}

};
那么，在使用的时候，我们可以：
A*a=newB();

a-&gt;foo();//在这里，a虽然是指向A的指针，但是被调用的函数(foo)却是B的!
这个例子是虚函数的一个典型应用，通过这个例子，也许你就对虚函数有了一些概念。它虚就虚在所谓“推迟联编”或者“动态联编”上，一个类函数的调用并不是在编译时刻被确定的，而是在运行时刻被确定的。由于编写代码的时候并不能确定被调用的是基类的函数还是哪个派生类的函数，所以被成为“虚”函数。
虚函数只能借助于指针或者引用来达到多态的效果，如果是下面这样的代码，则虽然是虚函数，但它不是多态的：
classA

{

public:

virtualvoidfoo();

};


classB:publicA

{

virtualvoidfoo();

};


voidbar()

{

Aa;

a.foo();//A::foo()被调用

}
在了解了虚函数的意思之后，再考虑什么是多态就很容易了。仍然针对上面的类层次，但是使用的方法变的复杂了一些：
voidbar(A*a)

{

a-&gt;foo();//被调用的是A::foo()还是B::foo()？

}


因为foo()是个虚函数，所以在bar这个函数中，只根据这段代码，无从确定这里被调用的是A::foo()还是B::foo()，但是可以肯定的说：如果a指向的是A类的实例，则A::foo()被调用，如果a指向的是B类的实例，则B::foo()被调用。
这种同一代码可以产生不同效果的特点，被称为“多态”。
多态这么神奇，但是能用来做什么呢？这个命题我难以用一两句话概括，一般的C&#43;&#43;教程（或者其它面向对象语言的教程）都用一个画图的例子来展示多态的用途，我就不再重复这个例子了，如果你不知道这个例子，随便找本书应该都有介绍。我试图从一个抽象的角度描述一下，回头再结合那个画图的例子，也许你就更容易理解。
在面向对象的编程中，首先会针对数据进行抽象（确定基类）和继承（确定派生类），构成类层次。这个类层次的使用者在使用它们的时候，如果仍然在需要基类的时候写针对基类的代码，在需要派生类的时候写针对派生类的代码，就等于类层次完全暴露在使用者面前。如果这个类层次有任何的改变（增加了新类），都需要使用者“知道”（针对新类写代码）。这样就增加了类层次与其使用者之间的耦合，有人把这种情况列为程序中的“badsmell”之一。
多态可以使程序员脱离这种窘境。再回头看看1.1中的例子，bar()作为A-B这个类层次的使用者，它并不知道这个类层次中有多少个类，每个类都叫什么，但是一样可以很好的工作，当有一个C类从A类派生出来后，bar()也不需要“知道”（修改）。这完全归功于多态--编译器针对虚函数产生了可以在运行时刻确定被调用函数的代码。
编译器是如何针对虚函数产生可以再运行时刻确定被调用函数的代码呢？也就是说，虚函数实际上是如何被编译器处理的呢？Lippman在深度探索C&#43;&#43;对象模型[1]中的不同章节讲到了几种方式，这里把“标准的”方式简单介绍一下。
我所说的“标准”方式，也就是所谓的“VTABLE”机制。编译器发现一个类中有被声明为virtual的函数，就会为其搞一个虚函数表，也就是VTABLE。VTABLE实际上是一个函数指针的数组，每个虚函数占用这个数组的一个slot。一个类只有一个VTABLE，不管它有多少个实例。派生类有自己的VTABLE，但是派生类的VTABLE与基类的VTABLE有相同的函数排列顺序，同名的虚函数被放在两个数组的相同位置上。在创建类实例的时候，编译器还会在每个实例的内存布局中增加一个vptr字段，该字段指向本类的VTABLE。通过这些手段，编译器在看到一个虚函数调用的时候，就会将这个调用改写，针对1.1中的例子：
voidbar(A*a)

{

a-&gt;foo();

}


会被改写为：
voidbar(A*a)

{

(a-&gt;vptr[1])();

}


因为派生类和基类的foo()函数具有相同的VTABLE索引，而他们的vptr又指向不同的VTABLE，因此通过这样的方法可以在运行时刻决定调用哪个foo()函数。
虽然实际情况远非这么简单，但是基本原理大致如此。
虚函数总是在派生类中被改写，这种改写被称为“override”。我经常混淆“overload”和“override”这两个单词。但是随着各类C&#43;&#43;的书越来越多，后来的程序员也许不会再犯我犯过的错误了。但是我打算澄清一下：
虚函数的标志是“virtual”关键字。
考虑下面的类层次：
classA

{

public:

virtualvoidfoo();

};


classB:publicA

{

public:

voidfoo();//没有virtual关键字!

};


classC:publicB//从B继承，不是从A继承！

{

public:

voidfoo();//也没有virtual关键字！

};
这种情况下，B::foo()是虚函数，C::foo()也同样是虚函数。因此，可以说，基类声明的虚函数，在派生类中也是虚函数，即使不再使用virtual关键字。
如下声明表示一个函数为纯虚函数：
classA

{

public:

virtualvoidfoo()=0;//=0标志一个虚函数为纯虚函数

};
一个函数声明为纯虚后，纯虚函数的意思是：我是一个抽象类！不要把我实例化！纯虚函数用来规范派生类的行为，实际上就是所谓的“接口”。它告诉使用者，我的派生类都会有这个函数。
析构函数也可以是虚的，甚至是纯虚的。例如：
classA

{

public:

virtual~A()=0;//纯虚析构函数

};
当一个类打算被用作其它类的基类时，它的析构函数必须是虚的。考虑下面的例子：
classA

{

public:

A(){ptra_=newchar[10];}

~A(){delete[]ptra_;}//非虚析构函数

private:

char*ptra_;

};


classB:publicA

{

public:

B(){ptrb_=newchar[20];}

~B(){delete[]ptrb_;}

private:

char*ptrb_;

};


voidfoo()

{

A*a=newB;

deletea;

}
在这个例子中，程序也许不会象你想象的那样运行，在执行deletea的时候，实际上只有A::~A()被调用了，而B类的析构函数并没有被调用！这是否有点儿可怕？
如果将上面A::~A()改为virtual，就可以保证B::~B()也在deletea的时候被调用了。因此基类的析构函数都必须是virtual的。
纯虚的析构函数并没有什么作用，是虚的就够了。通常只有在希望将一个类变成抽象类（不能实例化的类），而这个类又没有合适的函数可以被纯虚化的时候，可以使用纯虚的析构函数来达到目的。
构造函数不能是虚的。
考虑下面的例子：
classA

{

public:

voidfoo(){bar();}

private:

virtualvoidbar(){...}

};


classB:publicA

{

private:

virtualvoidbar(){...}

};


在这个例子中，虽然bar()在A类中是private的，但是仍然可以出现在派生类中，并仍然可以与public或者protected的虚函数一样产生多态的效果。并不会因为它是private的，就发生A::foo()不能访问B::bar()的情况，也不会发生B::bar()对A::bar()的override不起作用的情况。
这种写法的语意是：A告诉B，你最好override我的bar()函数，但是你不要管它如何使用，也不要自己调用这个函数。
一个类的虚函数在它自己的构造函数和析构函数中被调用的时候，它们就变成普通函数了，不“虚”了。也就是说不能在构造函数和析构函数中让自己“多态”。例如：
classA

{

public:

A(){foo();}//在这里，无论如何都是A::foo()被调用！

~A(){foo();}//同上

virtualvoidfoo();

};


classB:publicA

{

public:

virtualvoidfoo();

};


voidbar()

{

A*a=newB;

deletea;

}


如果你希望deletea的时候，会导致B::foo()被调用，那么你就错了。同样，在newB的时候，A的构造函数被调用，但是在A的构造函数中，被调用的是A::foo()而不是B::foo()。
在你设计一个基类的时候，如果发现一个函数需要在派生类里有不同的表现，那么它就应该是虚的。从设计的角度讲，出现在基类中的虚函数是接口，出现在派生类中的虚函数是接口的具体实现。通过这样的方法，就可以将对象的行为抽象化。
[1]深度探索C&#43;&#43;对象模型，StanleyB.Lippman，侯捷译
[2]DesignPatterns,ElementsofReusableObject-OrientedSoftware,GOF
