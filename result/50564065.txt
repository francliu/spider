operator是C&#43;&#43;的关键字，它和运算符一起使用，表示一个运算符函数，理解时应将operator=整体上视为一个函数名。
这是C&#43;&#43;扩展运算符功能的方法，虽然样子古怪，但也可以理解：一方面要使运算符的使用方法与其原来一致，另一方面扩展其功能只能通过函数的方式（c&#43;&#43;中，“功能”都是由函数实现的)。

一、为什么使用操作符重载？

对于系统的所有操作符，一般情况下，只支持基本数据类型和标准库中提供的class，对于用户自己定义的class，如果想支持基本操作，比如比较大小，判断是否相等，等等，则需要用户自己来定义关于这个操作符的具体实现。比如，判断两个人是否一样大，我们默认的规则是按照其年龄来比较，所以，在设计person这个class的时候，我们需要考虑操作符==，而且，根据刚才的分析，比较的依据应该是age。那么为什么叫重载呢？这是因为，在编译器实现的时候，已经为我们提供了这个操作符的基本数据类型实现版本，但是现在他的操作数变成了用户定义的数据类型class，所以，需要用户自己来提供该参数版本的实现。

二、如何声明一个重载的操作符？

A:

操作符重载实现为类成员函数

重载的操作符在类体中被声明，声明方式如同普通成员函数一样，只不过他的名字包含关键字operator，以及紧跟其后的一个c&#43;&#43;预定义的操作符。

可以用如下的方式来声明一个预定义的==操作符:

classperson{

private:





intage;





public:





person(inta){








this-&gt;age=a;





}




inlinebool
operator==
(constperson&amp;ps)const;

};

实现方式如下：

inlineboolperson::operator==(constperson&amp;ps)const

{
if(this-&gt;age==ps.age)









returntrue;






returnfalse;

}

调用方式如下：

#include

usingnamespacestd;

intmain()

{
personp1(10);



personp2(20);



if(p1==p2)cout&lt;&lt;”theageisequal!”&lt;return0;

}

这里，因为operator==是classperson的一个成员函数，所以对象p1,p2都可以调用该函数，上面的if语句中，相当于p1调用函数==，把p2作为该函数的一个参数传递给该函数，从而实现了两个对象的比较。
B:操作符重载实现为非类成员函数(全局函数)

对于全局重载操作符，代表左操作数的参数必须被显式指定。例如：

#include

#include

usingnamespacestd;

classperson

{

public:

intage;

public:

};


booloperator==(personconst&amp;p1
,personconst&amp;p2)
//满足要求，做操作数的类型被显示指定

{

if(p1.age==p2.age)

returntrue;

returnfalse;

}

intmain()

{

personrose;

personjack;

rose.age=18;

jack.age=23;

if(rose==jack)

cout&lt;&lt;&quot;ok&quot;&lt;return0;

}


C:如何决定把一个操作符重载为类成员函数还是全局名字空间的成员呢？

①如果一个重载操作符是类成员，那么只有当与他一起使用的左操作数是该类的对象时，该操作符才会被调用。如果该操作符的左操作数必须是其他的类型，则操作符必须被重载为全局名字空间的成员。

②C&#43;&#43;要求赋&#20540;=，下标[]，调用()，和成员指向-&gt;操作符必须被定义为类成员操作符。任何把这些操作符定义为名字空间成员的定义都会被标记为编译时刻错误。

③如果有一个操作数是类类型如string类的情形那么对于对称操作符比如等于操作符最好定义为全局名字空间成员。

D:重载操作符具有以下限制：
（1）只有C&#43;&#43;预定义的操作符集中的操作符才可以被重载；

（2）对于内置类型的操作符，它的预定义不能被改变，应不能为内置类型重载操作符，如，不能改变int型的操作符&#43;的含义；
（3）也不能为内置的数据类型定义其它的操作符；
（4）
只能重载类类型或枚举类型的操作符；
（5）
重载操作符不能改变它们的操作符优先级；
（6）重载操作符不能改变操作数的个数；
（7）
除了对()操作符外，对其他重载操作符提供缺省实参都是非法的；


E:
注意点

（1）后果载操操作符首先要确定它的返回&#20540;是左&#20540;，还是右&#20540;，如果是左&#20540;最返回引用，如果是右&#20540;那就直接返回&#20540;；
（2）&#43;号等这样的操作符没有对象可以容纳改变后&#20540;，对于这样的情况最好返回数&#20540;，否则只能要操作符体内创建临时对象用于容纳改变后的&#20540;，如果在堆中创建临时对象返回指针或者引用，在操作符函数体外还需要释放它，如果返回的对象而不是引用或者指针，那么效率是比较低的。如果返回的是数&#20540;，最好在该类的构造函数中增加对该类型数&#20540;的转换函数，如：返回&#20540;是int类型，那么最好有一个int类型作为参数的构造函数。
（3）在增量运算符中，放上一个整数形参，就是后增量运行符，它是&#20540;返回，对于前增量没有形参，而且是引用返回，示例：
classTest
{
public:
Test(x=3){m_value=x}
Test&amp;operator&#43;&#43;();


//前增量
Test&amp;operator&#43;&#43;(int);//后增量
private:
Intm_value:
};
Test&amp;Test::operator&#43;&#43;()
{
m_value&#43;&#43;;



//先增量
return*this;

//返回当前对象
}
TestTest::operator&#43;&#43;(int)
{
Testtmp(*this);

//创建临时对象
m_value&#43;&#43;;






//再增量
returntemp;





//返回临时对象
}
（4）因为强制转换是针对基本数据类型的，所以对类类型的转换需自定义；
（5）转换运行符重载声明形式：operator类型名();它没有返回类型，因为类型名就代表了它的返回类型，所以返回类型显得多余。
（6）一般来说，转换运算符与转换构造函数（即带一个参数的构造函数）是互逆的，如有了构造函数Test(int)，那么最好有一个转换运算符int()。这样就不必提供对象参数重载运算符了，如Testa1(1);Testa2(2);Testa3;a3=a1&#43;a2；就不需要重载&#43;号操作符了，因为对于a1&#43;a2的运算，系统可能会先找有没有定义针对Test的&#43;号操作符，如果没有，它就会找有没有针对Test类转换函数参数类型的&#43;号操作符（因为可以将&#43;号运行结果的类型通过转换函数转换为Test对象），因为Test类有个int类型的参数，对于int类型有&#43;操作符，所以a1&#43;a2真正执行的是Test(int(a1)
&#43;int(a2));即Test(3)；
（7）对于转换运算符，还有一个需要注意的地方就是，如果A类中有以B为参数的转换函数（构造函数），那B中不能有A的转换运算符，不然就存在转换的二义性，如：
classA{A(B&amp;){…}};classB{operatorA(){…}};那么以下语句就会有问题：
Bb;A(b);//A(b)有就可能是A的构造函数，也可以是B的转换运算符
operator是C&#43;&#43;的关键字，它和运算符一起使用，表示一个运算符函数，理解时应将operator=整体上视为一个函数名。
这是C&#43;&#43;扩展运算符功能的方法，虽然样子古怪，但也可以理解：一方面要使运算符的使用方法与其原来一致，另一方面扩展其功能只能通过函数的方式（c&#43;&#43;中，“功能”都是由函数实现的)。

一、为什么使用操作符重载？

对于系统的所有操作符，一般情况下，只支持基本数据类型和标准库中提供的class，对于用户自己定义的class，如果想支持基本操作，比如比较大小，判断是否相等，等等，则需要用户自己来定义关于这个操作符的具体实现。比如，判断两个人是否一样大，我们默认的规则是按照其年龄来比较，所以，在设计person这个class的时候，我们需要考虑操作符==，而且，根据刚才的分析，比较的依据应该是age。那么为什么叫重载呢？这是因为，在编译器实现的时候，已经为我们提供了这个操作符的基本数据类型实现版本，但是现在他的操作数变成了用户定义的数据类型class，所以，需要用户自己来提供该参数版本的实现。

二、如何声明一个重载的操作符？

A:

操作符重载实现为类成员函数

重载的操作符在类体中被声明，声明方式如同普通成员函数一样，只不过他的名字包含关键字operator，以及紧跟其后的一个c&#43;&#43;预定义的操作符。

可以用如下的方式来声明一个预定义的==操作符:

classperson{

private:





intage;





public:





person(inta){








this-&gt;age=a;





}




inlinebool
operator==
(constperson&amp;ps)const;

};

实现方式如下：

inlineboolperson::operator==(constperson&amp;ps)const

{
if(this-&gt;age==ps.age)









returntrue;






returnfalse;

}

调用方式如下：

#include

usingnamespacestd;

intmain()

{
personp1(10);



personp2(20);



if(p1==p2)cout&lt;&lt;”theageisequal!”&lt;return0;

}

这里，因为operator==是classperson的一个成员函数，所以对象p1,p2都可以调用该函数，上面的if语句中，相当于p1调用函数==，把p2作为该函数的一个参数传递给该函数，从而实现了两个对象的比较。
B:操作符重载实现为非类成员函数(全局函数)

对于全局重载操作符，代表左操作数的参数必须被显式指定。例如：

#include

#include

usingnamespacestd;

classperson

{

public:

intage;

public:

};


booloperator==(personconst&amp;p1
,personconst&amp;p2)
//满足要求，做操作数的类型被显示指定

{

if(p1.age==p2.age)

returntrue;

returnfalse;

}

intmain()

{

personrose;

personjack;

rose.age=18;

jack.age=23;

if(rose==jack)

cout&lt;&lt;&quot;ok&quot;&lt;return0;

}


C:如何决定把一个操作符重载为类成员函数还是全局名字空间的成员呢？

①如果一个重载操作符是类成员，那么只有当与他一起使用的左操作数是该类的对象时，该操作符才会被调用。如果该操作符的左操作数必须是其他的类型，则操作符必须被重载为全局名字空间的成员。

②C&#43;&#43;要求赋&#20540;=，下标[]，调用()，和成员指向-&gt;操作符必须被定义为类成员操作符。任何把这些操作符定义为名字空间成员的定义都会被标记为编译时刻错误。

③如果有一个操作数是类类型如string类的情形那么对于对称操作符比如等于操作符最好定义为全局名字空间成员。

D:重载操作符具有以下限制：
（1）只有C&#43;&#43;预定义的操作符集中的操作符才可以被重载；

（2）对于内置类型的操作符，它的预定义不能被改变，应不能为内置类型重载操作符，如，不能改变int型的操作符&#43;的含义；
（3）也不能为内置的数据类型定义其它的操作符；
（4）
只能重载类类型或枚举类型的操作符；
（5）
重载操作符不能改变它们的操作符优先级；
（6）重载操作符不能改变操作数的个数；
（7）
除了对()操作符外，对其他重载操作符提供缺省实参都是非法的；


E:
注意点

（1）后果载操操作符首先要确定它的返回&#20540;是左&#20540;，还是右&#20540;，如果是左&#20540;最返回引用，如果是右&#20540;那就直接返回&#20540;；
（2）&#43;号等这样的操作符没有对象可以容纳改变后&#20540;，对于这样的情况最好返回数&#20540;，否则只能要操作符体内创建临时对象用于容纳改变后的&#20540;，如果在堆中创建临时对象返回指针或者引用，在操作符函数体外还需要释放它，如果返回的对象而不是引用或者指针，那么效率是比较低的。如果返回的是数&#20540;，最好在该类的构造函数中增加对该类型数&#20540;的转换函数，如：返回&#20540;是int类型，那么最好有一个int类型作为参数的构造函数。
（3）在增量运算符中，放上一个整数形参，就是后增量运行符，它是&#20540;返回，对于前增量没有形参，而且是引用返回，示例：
classTest
{
public:
Test(x=3){m_value=x}
Test&amp;operator&#43;&#43;();


//前增量
Test&amp;operator&#43;&#43;(int);//后增量
private:
Intm_value:
};
Test&amp;Test::operator&#43;&#43;()
{
m_value&#43;&#43;;



//先增量
return*this;

//返回当前对象
}
TestTest::operator&#43;&#43;(int)
{
Testtmp(*this);

//创建临时对象
m_value&#43;&#43;;






//再增量
returntemp;





//返回临时对象
}
（4）因为强制转换是针对基本数据类型的，所以对类类型的转换需自定义；
（5）转换运行符重载声明形式：operator类型名();它没有返回类型，因为类型名就代表了它的返回类型，所以返回类型显得多余。
（6）一般来说，转换运算符与转换构造函数（即带一个参数的构造函数）是互逆的，如有了构造函数Test(int)，那么最好有一个转换运算符int()。这样就不必提供对象参数重载运算符了，如Testa1(1);Testa2(2);Testa3;a3=a1&#43;a2；就不需要重载&#43;号操作符了，因为对于a1&#43;a2的运算，系统可能会先找有没有定义针对Test的&#43;号操作符，如果没有，它就会找有没有针对Test类转换函数参数类型的&#43;号操作符（因为可以将&#43;号运行结果的类型通过转换函数转换为Test对象），因为Test类有个int类型的参数，对于int类型有&#43;操作符，所以a1&#43;a2真正执行的是Test(int(a1)
&#43;int(a2));即Test(3)；
（7）对于转换运算符，还有一个需要注意的地方就是，如果A类中有以B为参数的转换函数（构造函数），那B中不能有A的转换运算符，不然就存在转换的二义性，如：
classA{A(B&amp;){…}};classB{operatorA(){…}};那么以下语句就会有问题：
Bb;A(b);//A(b)有就可能是A的构造函数，也可以是B的转换运算符
