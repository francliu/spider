
1.NESTED
LOOP:
对于被连接的数据子集较小的情况，嵌套循环连接是个较好的选择。在嵌套循环中，内表被外表驱动，外表返回的每一行都要在内表中检索找到与它匹配的行，因此整个查询返回的结果集不能太大（大于1
万不适合），要把返回子集较小表的作为外表（CBO
默认外表是驱动表），而且在内表的连接字段上一定要有索引。当然也可以用ORDERED
提示来改变CBO默认的驱动表，使用USE_NL(table_name1table_name2)可是强制CBO
执行嵌套循环连接。
2.HASHJOIN散列连接
可用于实现自然连接和等&#20540;连接。在散列连接算法中，散列函数h用于对两个关系的元组进行划分。此算法的基本思想是把这两个关系的元组按连接属性划分为一些有相同散列&#20540;的元组集合。



hashjoin是CBO做大数据集连接时的常用方式。优化器扫描小表（或数据源），利用连接键（也就是根据连接字段计算hash&#20540;）在内存中建立hash表，然后扫描大表，每读到一条记录就来探测hash表一次，找出与hash表匹配的行。

当小表可以全部放入内存中，其成本接近全表扫描两个表的成本之和。如果表很大不能完全放入内存，这时优化器会将它分割成若干不同的分区，不能放入内存的部分就把该分区写入磁盘的临时段，此时要有较大的临时段从而尽量提高I/O的性能。临时段中的分区都需要换进内存做hashjoin。这时候成本接近于全表扫描小表&#43;分区数*全表扫描大表的代价和。
（对以上的过程保持疑问，可能是RDMS的问题，在《数据库系统概念》一书中，hashjoin算法的思想是这样的：对两个关系的连接属性分别作hash，hash函数一定要有较好的随机性和均匀性，如果关系r的一个元组和关系s的一个元组满足连接条件，那么他们在连接属性上有相同的&#20540;。如该&#20540;经散列函数映射为i，则关系s的那个元组必在H（ri）中，而关系s的那个元组必在H（si）中。因此，H（ri）中的元组只需与H（si）中的元组作比较，而没有必要与s的其他任何分区作比较。很明显这种算法比以上算法代价小的多。）




至于两个表都进行分区，其好处是可以使用parallelquery，就是多个进程同时对不同的分区进行join，然后再合并。但是复杂。

使用hashjoin时，HASH_AREA_SIZE初始化参数必须足够的大，如果是9i，Oracle建议使用SQL工作区自动管理，设置WORKAREA_SIZE_POLICY为AUTO，然后调整PGA_AGGREGATE_TARGET即可。

以下条件下hashjoin可能有优势：

两个巨大的表之间的连接。

在一个巨大的表和一个小表之间的连接。

可用ordered提示来改变CBO默认的驱动表，可用USE_HASH(table_name1table_name2)提示来强制使用hashjoin。
3.排序合并链接（SORTMERGEJOIN）
排序合并链接内部处理的流程如下。
（1）优化器判断第一个源表是否已经排序，如果已经排序，则到第3步，否则到第2步。
（2）第一个源表排序。
（3）优化器判断第二个源表是否已经排序，如果已经排序，则到第5步，否则到第4步。
（4）第二个源表排序。
（5）已经排过序的两个源表进行合并操作，并生成最终的结果集。
在缺乏数据的选择性或者可用的索引时，或者两个源表都过于庞大（所选的数据超过表记录数的5%）时，排序合并链接将比嵌套循环链接更加高效。排列合并链接需要比较大的临时内存块，以用于排序，这将导致在临时表空间占用更多的内存和磁盘I/O。通常情况下hashjoin的效果都比sortmergejoin要好，然而如果行源已经被排过序，在执行sortmergejoin时不需要再排序了，这时sort
mergejoin的性能会优于hashjoin.
可用USE_MERGE(table_name1table_name2)提示强制使用sortmergejoin.

1.NESTED
LOOP:
对于被连接的数据子集较小的情况，嵌套循环连接是个较好的选择。在嵌套循环中，内表被外表驱动，外表返回的每一行都要在内表中检索找到与它匹配的行，因此整个查询返回的结果集不能太大（大于1
万不适合），要把返回子集较小表的作为外表（CBO
默认外表是驱动表），而且在内表的连接字段上一定要有索引。当然也可以用ORDERED
提示来改变CBO默认的驱动表，使用USE_NL(table_name1table_name2)可是强制CBO
执行嵌套循环连接。
2.HASHJOIN散列连接
可用于实现自然连接和等&#20540;连接。在散列连接算法中，散列函数h用于对两个关系的元组进行划分。此算法的基本思想是把这两个关系的元组按连接属性划分为一些有相同散列&#20540;的元组集合。



hashjoin是CBO做大数据集连接时的常用方式。优化器扫描小表（或数据源），利用连接键（也就是根据连接字段计算hash&#20540;）在内存中建立hash表，然后扫描大表，每读到一条记录就来探测hash表一次，找出与hash表匹配的行。

当小表可以全部放入内存中，其成本接近全表扫描两个表的成本之和。如果表很大不能完全放入内存，这时优化器会将它分割成若干不同的分区，不能放入内存的部分就把该分区写入磁盘的临时段，此时要有较大的临时段从而尽量提高I/O的性能。临时段中的分区都需要换进内存做hashjoin。这时候成本接近于全表扫描小表&#43;分区数*全表扫描大表的代价和。
（对以上的过程保持疑问，可能是RDMS的问题，在《数据库系统概念》一书中，hashjoin算法的思想是这样的：对两个关系的连接属性分别作hash，hash函数一定要有较好的随机性和均匀性，如果关系r的一个元组和关系s的一个元组满足连接条件，那么他们在连接属性上有相同的&#20540;。如该&#20540;经散列函数映射为i，则关系s的那个元组必在H（ri）中，而关系s的那个元组必在H（si）中。因此，H（ri）中的元组只需与H（si）中的元组作比较，而没有必要与s的其他任何分区作比较。很明显这种算法比以上算法代价小的多。）




至于两个表都进行分区，其好处是可以使用parallelquery，就是多个进程同时对不同的分区进行join，然后再合并。但是复杂。

使用hashjoin时，HASH_AREA_SIZE初始化参数必须足够的大，如果是9i，Oracle建议使用SQL工作区自动管理，设置WORKAREA_SIZE_POLICY为AUTO，然后调整PGA_AGGREGATE_TARGET即可。

以下条件下hashjoin可能有优势：

两个巨大的表之间的连接。

在一个巨大的表和一个小表之间的连接。

可用ordered提示来改变CBO默认的驱动表，可用USE_HASH(table_name1table_name2)提示来强制使用hashjoin。
3.排序合并链接（SORTMERGEJOIN）
排序合并链接内部处理的流程如下。
（1）优化器判断第一个源表是否已经排序，如果已经排序，则到第3步，否则到第2步。
（2）第一个源表排序。
（3）优化器判断第二个源表是否已经排序，如果已经排序，则到第5步，否则到第4步。
（4）第二个源表排序。
（5）已经排过序的两个源表进行合并操作，并生成最终的结果集。
在缺乏数据的选择性或者可用的索引时，或者两个源表都过于庞大（所选的数据超过表记录数的5%）时，排序合并链接将比嵌套循环链接更加高效。排列合并链接需要比较大的临时内存块，以用于排序，这将导致在临时表空间占用更多的内存和磁盘I/O。通常情况下hashjoin的效果都比sortmergejoin要好，然而如果行源已经被排过序，在执行sortmergejoin时不需要再排序了，这时sort
mergejoin的性能会优于hashjoin.
可用USE_MERGE(table_name1table_name2)提示强制使用sortmergejoin.
