上一篇文章我提到inline函数对性能可能有较大的影响，这就促使我对这个inline函数做一个综合的深入研究。总结起来使用inline函数有如下几点：
注意这里讨论的只是类的成员函数。
1。在类的声明里实现的函数自动为inline。也可以在类申明外定义为inline。但是这一部分必须与类的声明在同一个.h文件里。如果定义在cpp文件里，就会给出编译错误。我开头就很不明白，为什么我的inline就不行呢？原因就在于这个规则。
2。很多人喜欢把inline函数直接写在类声明里，包括stl,都是这么写的。我在阅读这些程序时，就经常发现思维被函数的实现牵引走，从而对类的接口变得模糊。因此建议不要在类声明里写实现，不管他多简单。这样虽然对些程序的人来说麻烦一些，但是这样写出的程序要清晰多了。用户或者读者不必要深入到实现细节，而可以关注类的接口上面。对大多数使用来说，实现细节是完全可以不用了解的。比如你使用STL的类，难道还非要明白他们是怎么实现的吗？
3。inline函数与性能的关系不是一个肯定的关系，有可能加快，也有可能会变慢。有可能使代码变大，也有可能变小。要测试才能知道。
4。inline函数比macro要好。因为inline函数更像一个函数，它也作类型检查，匹配。macro就只会简单得展开。在很多情况下，macro展开有可能导致难以查到的错误！有大量C程序经验的人对此不会陌生。
比如一个求绝对&#20540;：
用macro:
#defineabs(x)(x)&gt;0?(x):-(x)
abs(i&#43;&#43;)会被展开为：(i&#43;&#43;)&gt;0?(i&#43;&#43;):-(i&#43;&#43;)
显然这不是我们想要的。因为i&#43;&#43;被执行了两次。

inlineintabs(x){x&gt;0?x:-x;}
abs(i&#43;&#43;)等价为：
j=i&#43;&#43;;j&gt;0?j:-j;
上一篇文章我提到inline函数对性能可能有较大的影响，这就促使我对这个inline函数做一个综合的深入研究。总结起来使用inline函数有如下几点：
注意这里讨论的只是类的成员函数。
1。在类的声明里实现的函数自动为inline。也可以在类申明外定义为inline。但是这一部分必须与类的声明在同一个.h文件里。如果定义在cpp文件里，就会给出编译错误。我开头就很不明白，为什么我的inline就不行呢？原因就在于这个规则。
2。很多人喜欢把inline函数直接写在类声明里，包括stl,都是这么写的。我在阅读这些程序时，就经常发现思维被函数的实现牵引走，从而对类的接口变得模糊。因此建议不要在类声明里写实现，不管他多简单。这样虽然对些程序的人来说麻烦一些，但是这样写出的程序要清晰多了。用户或者读者不必要深入到实现细节，而可以关注类的接口上面。对大多数使用来说，实现细节是完全可以不用了解的。比如你使用STL的类，难道还非要明白他们是怎么实现的吗？
3。inline函数与性能的关系不是一个肯定的关系，有可能加快，也有可能会变慢。有可能使代码变大，也有可能变小。要测试才能知道。
4。inline函数比macro要好。因为inline函数更像一个函数，它也作类型检查，匹配。macro就只会简单得展开。在很多情况下，macro展开有可能导致难以查到的错误！有大量C程序经验的人对此不会陌生。
比如一个求绝对&#20540;：
用macro:
#defineabs(x)(x)&gt;0?(x):-(x)
abs(i&#43;&#43;)会被展开为：(i&#43;&#43;)&gt;0?(i&#43;&#43;):-(i&#43;&#43;)
显然这不是我们想要的。因为i&#43;&#43;被执行了两次。

inlineintabs(x){x&gt;0?x:-x;}
abs(i&#43;&#43;)等价为：
j=i&#43;&#43;;j&gt;0?j:-j;
