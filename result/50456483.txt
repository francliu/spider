在看C&#43;&#43;编程思想中，每个练习基本都是使用ofstream,ifstream,fstream，以前粗略知道其用法和含义，在看了几位大牛的博文后，进行整理和总结：

这里主要是讨论fstream的内容：
1.打开文件
在fstream类中，成员函数open（）实现打开文件的操作，从而将数据流和文件进行关联，通过ofstream,ifstream,fstream对象进行对文件的读写操作
函数：open（）
mode






打开文件的方式
prot







打开文件的属性


























//基本很少用到，在查看资料时，发现有两种方式
打开文件的方式在ios类(所以流式I/O的基类)中定义，有如下几种方式：

很多程序中，可能会碰到ofstreamout(&quot;Hello.txt&quot;),ifstreamin(&quot;...&quot;),fstreamfoi(&quot;...&quot;)这样的的使用，并没有显式的去调用open（）函数就进行文件的操作，直接调用了其默认的打开方式，因为在stream类的构造函数中调用了open()函数,并拥有同样的构造函数，所以在这里可以直接使用流对象进行文件的操作，默认方式如下：
2.关闭文件
当文件读写操作完成之后，我们必须将文件关闭以使文件重新变为可访问的。成员函数close()，它负责将缓存中的数据排放出来并关闭文件。这个函数一旦被调用，原先的流对象就可以被用来打开其它的文件了，这个文件也就可以重新被其它的进程所访问了。为防止流对象被销毁时还联系着打开的文件，析构函数将会自动调用关闭函数close。

3.文本文件的读写
类ofstream,ifstream和fstream是分别从ostream,istream和iostream中引申而来的。这就是为什么fstream的对象可以使用其父类的成员来访问数据。
一般来说，我们将使用这些类与同控制台(console)交互同样的成员函数(cin和cout)来进行输入输出。如下面的例题所示，我们使用重载的插入操作符&lt;&lt;：
从文件中读入数据也可以用与cin&gt;&gt;的使用同样的方法：
上面的例子读入一个文本文件的内容，然后将它打印到屏幕上。注意我们使用了一个新的成员函数叫做eof，它是ifstream从类ios中继承过来的，当到达文件末尾时返回true。
除了eof()以外，还有一些验证流的状态的成员函数（所有都返回bool型返回&#20540;）：
如果在读写过程中出错，返回true。例如：当我们要对一个不是打开为写状态的文件进行写入时，或者我们要写入的设备没有剩余空间的时候。
除了与bad()同样的情况下会返回true以外，加上&#26684;式错误时也返回true，例如当想要读入一个整数，而获得了一个字母的时候。
如果读文件到达文件末尾，返回true。
这是最通用的：如果调用以上任何一个函数返回true的话，此函数返回false。
要想重置以上成员函数所检查的状态标志，你可以使用成员函数clear()，没有参数。
所有输入/输出流对象(i/ostreamsobjects)都有至少一个流指针：
我们可以通过使用以下成员函数来读出或配置这些指向流中读写位置的流指针：
这两个成员函数不用传入参数，返回pos_type类型的&#20540;(根据ANSI-C&#43;&#43;标准)，就是一个整数，代表当前get流指针的位置(用tellg)或put流指针的位置(用tellp).
这对函数分别用来改变流指针get和put的位置。两个函数都被重载为两种不同的原型：
使用这个原型，流指针被改变为指向从文件开始计算的一个绝对位置。要求传入的参数类型与函数tellg和tellp的返回&#20540;类型相同。
使用这个原型可以指定由参数direction决定的一个具体的指针开始计算的一个位移(offset)。它可以是：
流指针get和put的&#20540;对文本文件(textfile)和二进制文件(binaryfile)的计算方法都是不同的，因为文本模式的文件中某些特殊字符可能被修改。由于这个原因，建议对以文本文件模式打开的文件总是使用seekg和seekp的第一种原型，而且不要对tellg或tellp的返回&#20540;进行修改。对二进制文件，你可以任意使用这些函数，应该不会有任何意外的行为产生。
以下例子使用这些函数来获得一个二进制文件的大小：

在二进制文件中，使用&lt;&lt;和&gt;&gt;，以及函数（如getline）来操作符输入和输出数据，没有什么实际意义，虽然它们是符合语法的。
文件流包括两个为顺序读写数据特殊设计的成员函数：write和read。第一个函数(write)是ostream的一个成员函数，都是被ofstream所继承。而read是istream的一个成员函数，被ifstream所继承。类fstream的对象同时拥有这两个函数。它们的原型是：
这里buffer是一块内存的地址，用来存储或读出数据。参数size是一个整数&#20540;，表示要从缓存（buffer）中读出或写入的字符数。

当我们对文件流进行操作的时候，它们与一个streambuf类型的缓存(buffer)联系在一起。这个缓存（buffer）实际是一块内存空间，作为流(stream)和物理文件的媒介。例如，对于一个输出流，每次成员函数put(写一个单个字符)被调用，这个字符不是直接被写入该输出流所对应的物理文件中的，而是首先被插入到该流的缓存（buffer）中。
当缓存被排放出来(flush)时，它里面的所有数据或者被写入物理媒质中（如果是一个输出流的话），或者简单的被抹掉(如果是一个输入流的话)。这个过程称为同步(synchronization)，它会在以下任一情况下发生：
在看C&#43;&#43;编程思想中，每个练习基本都是使用ofstream,ifstream,fstream，以前粗略知道其用法和含义，在看了几位大牛的博文后，进行整理和总结：

这里主要是讨论fstream的内容：
1.打开文件
在fstream类中，成员函数open（）实现打开文件的操作，从而将数据流和文件进行关联，通过ofstream,ifstream,fstream对象进行对文件的读写操作
函数：open（）
mode






打开文件的方式
prot







打开文件的属性


























//基本很少用到，在查看资料时，发现有两种方式
打开文件的方式在ios类(所以流式I/O的基类)中定义，有如下几种方式：

很多程序中，可能会碰到ofstreamout(&quot;Hello.txt&quot;),ifstreamin(&quot;...&quot;),fstreamfoi(&quot;...&quot;)这样的的使用，并没有显式的去调用open（）函数就进行文件的操作，直接调用了其默认的打开方式，因为在stream类的构造函数中调用了open()函数,并拥有同样的构造函数，所以在这里可以直接使用流对象进行文件的操作，默认方式如下：
2.关闭文件
当文件读写操作完成之后，我们必须将文件关闭以使文件重新变为可访问的。成员函数close()，它负责将缓存中的数据排放出来并关闭文件。这个函数一旦被调用，原先的流对象就可以被用来打开其它的文件了，这个文件也就可以重新被其它的进程所访问了。为防止流对象被销毁时还联系着打开的文件，析构函数将会自动调用关闭函数close。

3.文本文件的读写
类ofstream,ifstream和fstream是分别从ostream,istream和iostream中引申而来的。这就是为什么fstream的对象可以使用其父类的成员来访问数据。
一般来说，我们将使用这些类与同控制台(console)交互同样的成员函数(cin和cout)来进行输入输出。如下面的例题所示，我们使用重载的插入操作符&lt;&lt;：
从文件中读入数据也可以用与cin&gt;&gt;的使用同样的方法：
上面的例子读入一个文本文件的内容，然后将它打印到屏幕上。注意我们使用了一个新的成员函数叫做eof，它是ifstream从类ios中继承过来的，当到达文件末尾时返回true。
除了eof()以外，还有一些验证流的状态的成员函数（所有都返回bool型返回&#20540;）：
如果在读写过程中出错，返回true。例如：当我们要对一个不是打开为写状态的文件进行写入时，或者我们要写入的设备没有剩余空间的时候。
除了与bad()同样的情况下会返回true以外，加上&#26684;式错误时也返回true，例如当想要读入一个整数，而获得了一个字母的时候。
如果读文件到达文件末尾，返回true。
这是最通用的：如果调用以上任何一个函数返回true的话，此函数返回false。
要想重置以上成员函数所检查的状态标志，你可以使用成员函数clear()，没有参数。
所有输入/输出流对象(i/ostreamsobjects)都有至少一个流指针：
我们可以通过使用以下成员函数来读出或配置这些指向流中读写位置的流指针：
这两个成员函数不用传入参数，返回pos_type类型的&#20540;(根据ANSI-C&#43;&#43;标准)，就是一个整数，代表当前get流指针的位置(用tellg)或put流指针的位置(用tellp).
这对函数分别用来改变流指针get和put的位置。两个函数都被重载为两种不同的原型：
使用这个原型，流指针被改变为指向从文件开始计算的一个绝对位置。要求传入的参数类型与函数tellg和tellp的返回&#20540;类型相同。
使用这个原型可以指定由参数direction决定的一个具体的指针开始计算的一个位移(offset)。它可以是：
流指针get和put的&#20540;对文本文件(textfile)和二进制文件(binaryfile)的计算方法都是不同的，因为文本模式的文件中某些特殊字符可能被修改。由于这个原因，建议对以文本文件模式打开的文件总是使用seekg和seekp的第一种原型，而且不要对tellg或tellp的返回&#20540;进行修改。对二进制文件，你可以任意使用这些函数，应该不会有任何意外的行为产生。
以下例子使用这些函数来获得一个二进制文件的大小：

在二进制文件中，使用&lt;&lt;和&gt;&gt;，以及函数（如getline）来操作符输入和输出数据，没有什么实际意义，虽然它们是符合语法的。
文件流包括两个为顺序读写数据特殊设计的成员函数：write和read。第一个函数(write)是ostream的一个成员函数，都是被ofstream所继承。而read是istream的一个成员函数，被ifstream所继承。类fstream的对象同时拥有这两个函数。它们的原型是：
这里buffer是一块内存的地址，用来存储或读出数据。参数size是一个整数&#20540;，表示要从缓存（buffer）中读出或写入的字符数。

当我们对文件流进行操作的时候，它们与一个streambuf类型的缓存(buffer)联系在一起。这个缓存（buffer）实际是一块内存空间，作为流(stream)和物理文件的媒介。例如，对于一个输出流，每次成员函数put(写一个单个字符)被调用，这个字符不是直接被写入该输出流所对应的物理文件中的，而是首先被插入到该流的缓存（buffer）中。
当缓存被排放出来(flush)时，它里面的所有数据或者被写入物理媒质中（如果是一个输出流的话），或者简单的被抹掉(如果是一个输入流的话)。这个过程称为同步(synchronization)，它会在以下任一情况下发生：
