先看一段程序

这段程序的输出会是什么呢？
显然(int)a是将a的&#20540;转换成int型
&amp;a则是a的内存地址的二进制表示
那么(int&amp;)a是什么呢？是否等于(int)&amp;a呢？
【注意：(int)&amp;a实际是将二进制的地址转化成int型】
我们看一下程序运行的结果：

(int&amp;)a的&#20540;很古怪，1065353216
不妨尝试输出(int)&amp;a,就会发现(int&amp;)a≠(int)&amp;a
实际上，(int&amp;a)是与*((int*)&amp;a)等价的，意思都是将&amp;a这个地址上的32位看成int型，即使存储在这里的可能不是int型数据
(int&amp;)a为什么会是1065353216呢？
这和浮点数在内存中的存储&#26684;式有关，float1.0在内存中存储为（按IEEE754规定）:
符号位









阶(8位)
























尾数(23位)



0










01111111





00000000000000000000000
于是将其看做int型数&#20540;的话
00111111100000000000000000000000(2)

=

1065353216(10)
这正是程序输出的结果
小结：
(int)a实际上是以浮点数a为参数构造了一个整型数，该整数的&#20540;是1。
(int&amp;)a则是告诉编译器将a当作整数看（并没有做任何实质上的转换）。
因为1以整数形式存放和以浮点形式存放其内存数据是不一样的，因此两者不等。
对b的两种转换意义同上，但是0的整数形式和浮点形式其内存数据是一样的，因此在这种特殊情形下，两者相等（仅仅在数&#20540;意义上）。
先看一段程序

这段程序的输出会是什么呢？
显然(int)a是将a的&#20540;转换成int型
&amp;a则是a的内存地址的二进制表示
那么(int&amp;)a是什么呢？是否等于(int)&amp;a呢？
【注意：(int)&amp;a实际是将二进制的地址转化成int型】
我们看一下程序运行的结果：

(int&amp;)a的&#20540;很古怪，1065353216
不妨尝试输出(int)&amp;a,就会发现(int&amp;)a≠(int)&amp;a
实际上，(int&amp;a)是与*((int*)&amp;a)等价的，意思都是将&amp;a这个地址上的32位看成int型，即使存储在这里的可能不是int型数据
(int&amp;)a为什么会是1065353216呢？
这和浮点数在内存中的存储&#26684;式有关，float1.0在内存中存储为（按IEEE754规定）:
符号位









阶(8位)
























尾数(23位)



0










01111111





00000000000000000000000
于是将其看做int型数&#20540;的话
00111111100000000000000000000000(2)

=

1065353216(10)
这正是程序输出的结果
小结：
(int)a实际上是以浮点数a为参数构造了一个整型数，该整数的&#20540;是1。
(int&amp;)a则是告诉编译器将a当作整数看（并没有做任何实质上的转换）。
因为1以整数形式存放和以浮点形式存放其内存数据是不一样的，因此两者不等。
对b的两种转换意义同上，但是0的整数形式和浮点形式其内存数据是一样的，因此在这种特殊情形下，两者相等（仅仅在数&#20540;意义上）。
